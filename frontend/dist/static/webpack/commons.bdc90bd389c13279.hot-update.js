"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("commons",{

/***/ "./src/pages/api.js":
/*!**************************!*\
  !*** ./src/pages/api.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_URL: function() { return /* binding */ API_URL; },\n/* harmony export */   WC_CONSUMER_KEY: function() { return /* binding */ WC_CONSUMER_KEY; },\n/* harmony export */   WC_CONSUMER_SECRET: function() { return /* binding */ WC_CONSUMER_SECRET; },\n/* harmony export */   \"default\": function() { return /* binding */ handler; },\n/* harmony export */   deleteBlogPost: function() { return /* binding */ deleteBlogPost; },\n/* harmony export */   getBlogById: function() { return /* binding */ getBlogById; },\n/* harmony export */   getBlogPosts: function() { return /* binding */ getBlogPosts; },\n/* harmony export */   getCountryPrefix: function() { return /* binding */ getCountryPrefix; },\n/* harmony export */   getPropertyById: function() { return /* binding */ getPropertyById; },\n/* harmony export */   getPropertyPosts: function() { return /* binding */ getPropertyPosts; },\n/* harmony export */   handleApiError: function() { return /* binding */ handleApiError; },\n/* harmony export */   sendEmail: function() { return /* binding */ sendEmail; },\n/* harmony export */   sendPropertyEmail: function() { return /* binding */ sendPropertyEmail; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n// Exportar solo las funciones de utilidad sin crear una ruta API\nconst API_URL = \"https://goza-madrid.onrender.com\" || 0;\n// Definir las claves de API de WooCommerce\nconst WC_CONSUMER_KEY = process.env.NEXT_PUBLIC_NEXT_PUBLIC_WOO_COMMERCE_KEY;\nconst WC_CONSUMER_SECRET = \"cs_f194d11b41ca92cdd356145705fede711cd233e5\";\n// Función auxiliar para manejar errores\nconst handleApiError = (error, functionName)=>{\n    console.error(\"Error en \".concat(functionName, \":\"), error);\n    if (error.response) {\n        // El servidor respondió con un código de error\n        throw new Error(\"Error \".concat(error.response.status, \": \").concat(error.response.statusText));\n    } else if (error.request) {\n        // La petición fue hecha pero no se recibió respuesta\n        throw new Error(\"No se recibi\\xf3 respuesta del servidor\");\n    } else {\n        // Error al configurar la petición\n        throw new Error(error.message || \"Error desconocido\");\n    }\n};\nasync function getCountryPrefix() {\n    try {\n        console.log(\"Intentando obtener prefijos de pa\\xeds desde la API local\");\n        // Usar AbortController para evitar bloqueos\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), 5000); // 5 segundos timeout\n        const response = await fetch(\"\".concat(API_URL, \"/prefix\"), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n        // Si la respuesta fue exitosa y es JSON, devolver los datos\n        if (response.ok) {\n            const contentType = response.headers.get(\"content-type\");\n            if (contentType && contentType.includes(\"application/json\")) {\n                return await response.json();\n            }\n        }\n        // Si algo falla, devolver prefijos por defecto\n        console.log(\"Usando prefijos de pa\\xeds por defecto\");\n        return getDefaultCountryPrefixes();\n    } catch (error) {\n        console.error(\"Error al obtener prefijos de pa\\xeds:\", error.message);\n        // En caso de error, devolver prefijos por defecto\n        return getDefaultCountryPrefixes();\n    }\n}\n// Esta es la forma correcta, un junior podría hacerlo así:\nasync function getBlogPosts() {\n    // Array donde guardaremos todos los blogs\n    let allBlogs = [];\n    // 1. Intentar obtener blogs de WordPress usando nuestro proxy\n    try {\n        console.log(\"Obteniendo blogs de WordPress...\");\n        // Usar el proxy con el parámetro endpoint=wp para indicar que queremos la API de WordPress\n        const wpResponse = await fetch(\"/api/wordpress-proxy?endpoint=wp&path=posts&_embed=true\");\n        console.log(\"Respuesta de WordPress:\", {\n            status: wpResponse.status,\n            statusText: wpResponse.statusText\n        });\n        if (wpResponse.ok) {\n            const wpBlogs = await wpResponse.json();\n            console.log(\"Obtenidos \".concat(wpBlogs.length, \" blogs de WordPress\"));\n            // Añadir los blogs de WordPress al array, con la fuente marcada\n            wpBlogs.forEach((blog)=>{\n                var _blog_title, _blog_title1, _blog_content, _blog_excerpt;\n                // Procesar la imagen destacada\n                let featuredImage = null;\n                // Intentar obtener la imagen destacada desde _embedded\n                if (blog._embedded && blog._embedded[\"wp:featuredmedia\"] && blog._embedded[\"wp:featuredmedia\"][0]) {\n                    const media = blog._embedded[\"wp:featuredmedia\"][0];\n                    if (media.media_details && media.media_details.sizes) {\n                        // Buscar la mejor imagen disponible\n                        const sizePriority = [\n                            \"medium_large\",\n                            \"medium\",\n                            \"large\",\n                            \"full\"\n                        ];\n                        for (const size of sizePriority){\n                            if (media.media_details.sizes[size]) {\n                                featuredImage = media.media_details.sizes[size].source_url;\n                                break;\n                            }\n                        }\n                    }\n                    // Si no se encontró ninguna imagen en los tamaños, usar la URL de origen\n                    if (!featuredImage && media.source_url) {\n                        featuredImage = media.source_url;\n                    }\n                }\n                // Si no hay imagen destacada, intentar obtenerla de uagb_featured_image_src\n                if (!featuredImage && blog.uagb_featured_image_src) {\n                    var _blog_uagb_featured_image_src_medium, _blog_uagb_featured_image_src_full;\n                    featuredImage = ((_blog_uagb_featured_image_src_medium = blog.uagb_featured_image_src.medium) === null || _blog_uagb_featured_image_src_medium === void 0 ? void 0 : _blog_uagb_featured_image_src_medium[0]) || ((_blog_uagb_featured_image_src_full = blog.uagb_featured_image_src.full) === null || _blog_uagb_featured_image_src_full === void 0 ? void 0 : _blog_uagb_featured_image_src_full[0]);\n                }\n                // Si aún no hay imagen, usar una imagen por defecto\n                if (!featuredImage) {\n                    featuredImage = \"/img/default-blog-image.jpg\";\n                }\n                // Crear el objeto de blog con la imagen procesada\n                allBlogs.push({\n                    ...blog,\n                    image: {\n                        src: featuredImage,\n                        alt: ((_blog_title = blog.title) === null || _blog_title === void 0 ? void 0 : _blog_title.rendered) || blog.title || \"Imagen del blog\"\n                    },\n                    title: ((_blog_title1 = blog.title) === null || _blog_title1 === void 0 ? void 0 : _blog_title1.rendered) || blog.title || \"\",\n                    content: ((_blog_content = blog.content) === null || _blog_content === void 0 ? void 0 : _blog_content.rendered) || blog.content || \"\",\n                    excerpt: ((_blog_excerpt = blog.excerpt) === null || _blog_excerpt === void 0 ? void 0 : _blog_excerpt.rendered) || blog.excerpt || \"\",\n                    source: \"wordpress\"\n                });\n            });\n        } else {\n            const errorData = await wpResponse.json();\n            console.error(\"Error al obtener blogs de WordPress: \".concat(wpResponse.status), errorData);\n        }\n    } catch (error) {\n        console.error(\"Error con WordPress:\", error.message);\n    }\n    // 2. Intentar obtener blogs de MongoDB usando la API directa\n    try {\n        console.log(\"Obteniendo blogs de MongoDB...\");\n        // Usar la ruta correcta con API_URL\n        const mongoResponse = await fetch(\"\".concat(API_URL, \"/blog\"), {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        console.log(\"Respuesta de MongoDB:\", {\n            status: mongoResponse.status,\n            statusText: mongoResponse.statusText\n        });\n        if (mongoResponse.ok) {\n            const contentType = mongoResponse.headers.get(\"content-type\");\n            if (contentType && contentType.includes(\"application/json\")) {\n                const mongoBlogs = await mongoResponse.json();\n                console.log(\"Obtenidos \".concat(mongoBlogs.length, \" blogs de MongoDB\"));\n                // Añadir los blogs de MongoDB al array, con la fuente marcada\n                mongoBlogs.forEach((blog)=>{\n                    // Procesar las imágenes según el esquema\n                    let blogImages = [];\n                    // Verificar si el blog tiene imágenes\n                    if (blog.images && Array.isArray(blog.images) && blog.images.length > 0) {\n                        // Usar las imágenes del esquema\n                        blogImages = blog.images.map((img)=>{\n                            // Asegurarse de que la URL sea absoluta\n                            const src = typeof img === \"string\" ? img : img.src || \"\";\n                            const imgSrc = src.startsWith(\"http\") ? src : \"\".concat(API_URL).concat(src.startsWith(\"/\") ? \"\" : \"/\").concat(src);\n                            return {\n                                src: imgSrc,\n                                alt: typeof img === \"object\" && img.alt ? img.alt : blog.title || \"Imagen del blog\"\n                            };\n                        });\n                    } else if (blog.image) {\n                        // Compatibilidad con el formato anterior\n                        if (typeof blog.image === \"string\") {\n                            // Si la imagen es una cadena, crear un objeto de imagen\n                            const baseUrl = API_URL;\n                            const imageSrc = blog.image.startsWith(\"http\") ? blog.image : \"\".concat(baseUrl).concat(blog.image.startsWith(\"/\") ? \"\" : \"/\").concat(blog.image);\n                            blogImages = [\n                                {\n                                    src: imageSrc,\n                                    alt: blog.title || \"Imagen del blog\"\n                                }\n                            ];\n                        } else {\n                            // Si ya es un objeto, asegurarse de que la URL sea absoluta\n                            const baseUrl = API_URL;\n                            const src = blog.image.src || blog.image.url || \"\";\n                            blogImages = [\n                                {\n                                    ...blog.image,\n                                    src: src.startsWith(\"http\") ? src : \"\".concat(baseUrl).concat(src.startsWith(\"/\") ? \"\" : \"/\").concat(src)\n                                }\n                            ];\n                        }\n                    } else {\n                        // Si no hay imágenes, usar una por defecto\n                        blogImages = [\n                            {\n                                src: \"/img/default-blog-image.jpg\",\n                                alt: blog.title || \"Imagen del blog\"\n                            }\n                        ];\n                    }\n                    // Asegurarse de que el blog tenga todos los campos necesarios\n                    allBlogs.push({\n                        ...blog,\n                        _id: blog._id || \"mongo-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9)),\n                        title: blog.title || \"Sin t\\xedtulo\",\n                        content: blog.content || blog.description || \"\",\n                        description: blog.description || blog.excerpt || \"\",\n                        date: blog.createdAt || blog.date || new Date().toISOString(),\n                        dateFormatted: blog.dateFormatted || (blog.createdAt ? new Date(blog.createdAt).toLocaleDateString(\"es-ES\") : new Date().toLocaleDateString(\"es-ES\")),\n                        images: blogImages,\n                        image: blogImages[0] || {\n                            src: \"/img/default-blog-image.jpg\",\n                            alt: \"Imagen del blog\"\n                        },\n                        source: \"mongodb\"\n                    });\n                });\n            } else {\n                console.error(\"La respuesta no es JSON v\\xe1lido:\", await mongoResponse.text());\n            }\n        } else {\n            try {\n                const errorText = await mongoResponse.text();\n                console.error(\"Error al obtener blogs de MongoDB: \".concat(mongoResponse.status), errorText);\n            } catch (e) {\n                console.error(\"Error al obtener blogs de MongoDB: \".concat(mongoResponse.status), mongoResponse.statusText);\n            }\n        }\n    } catch (error) {\n        console.error(\"Error con MongoDB:\", error.message);\n    }\n    console.log(\"Total de blogs obtenidos: \".concat(allBlogs.length));\n    return allBlogs;\n}\nasync function deleteBlogPost(id) {\n    const response = await fetch(\"\".concat(API_URL, \"/blog/\").concat(id), {\n        method: \"DELETE\"\n    });\n    return response.json();\n}\nasync function getBlogById(id) {\n    try {\n        console.log(\"[DEBUG] Iniciando getBlogById para ID: \".concat(id));\n        // Verificar si estamos en producción\n        const isProduction = \"development\" === \"production\";\n        console.log(\"[DEBUG] \\xbfEstamos en producci\\xf3n? \".concat(isProduction));\n        // Verificar si es un ID de MongoDB\n        const isMongoId = /^[0-9a-fA-F]{24}$/.test(id);\n        console.log(\"[DEBUG] \\xbfEs ID de MongoDB? \".concat(isMongoId));\n        // Configuración de timeout y reintentos para producción\n        const maxRetries = isProduction ? 3 : 1;\n        const timeout = isProduction ? 20000 : 10000;\n        const retryDelay = 1000;\n        let lastError = null;\n        for(let attempt = 1; attempt <= maxRetries; attempt++){\n            try {\n                console.log(\"[DEBUG] Intento \".concat(attempt, \" de \").concat(maxRetries));\n                // Crear un controlador de aborto para el timeout\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>{\n                    console.log(\"[DEBUG] Timeout alcanzado en intento \".concat(attempt));\n                    controller.abort();\n                }, timeout);\n                let response;\n                if (isMongoId) {\n                    // Es un ID de MongoDB\n                    const baseUrl =  false ? 0 : \"\";\n                    const url = \"\".concat(baseUrl, \"/blog/\").concat(id);\n                    console.log(\"[DEBUG] Intentando obtener blog de MongoDB: \".concat(url));\n                    response = await fetch(url, {\n                        signal: controller.signal,\n                        headers: {\n                            \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n                            \"Pragma\": \"no-cache\",\n                            \"Expires\": \"0\"\n                        }\n                    });\n                } else {\n                    // Es un ID de WordPress\n                    const url = \"/api/wordpress-proxy?endpoint=wp&path=posts/\".concat(id, \"&_embed=true\");\n                    console.log(\"[DEBUG] Intentando obtener blog de WordPress: \".concat(url));\n                    response = await fetch(url, {\n                        signal: controller.signal,\n                        headers: {\n                            \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n                            \"Pragma\": \"no-cache\",\n                            \"Expires\": \"0\"\n                        }\n                    });\n                }\n                clearTimeout(timeoutId);\n                if (!response.ok) {\n                    throw new Error(\"Error HTTP: \".concat(response.status));\n                }\n                const data = await response.json();\n                // Procesar y devolver los datos según el tipo\n                if (isMongoId) {\n                    return procesarBlogMongoDB(data);\n                } else {\n                    return procesarBlogWordPress(data);\n                }\n            } catch (error) {\n                console.error(\"[DEBUG] Error en intento \".concat(attempt, \":\"), error);\n                lastError = error;\n                if (attempt < maxRetries) {\n                    console.log(\"[DEBUG] Esperando \".concat(retryDelay, \"ms antes del siguiente intento\"));\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                }\n            }\n        }\n        throw lastError || new Error(\"Error al obtener el blog despu\\xe9s de varios intentos\");\n    } catch (error) {\n        console.error(\"[DEBUG] Error final en getBlogById:\", error);\n        throw error;\n    }\n}\n// Función auxiliar para procesar blogs de MongoDB\nfunction procesarBlogMongoDB(data) {\n    var _blogImages_;\n    let blogImages = [];\n    if (data.images && Array.isArray(data.images) && data.images.length > 0) {\n        blogImages = data.images.map((img)=>{\n            const src = typeof img === \"string\" ? img : img.src || \"\";\n            const imgSrc = src.startsWith(\"http\") ? src : \"\".concat(API_URL).concat(src.startsWith(\"/\") ? \"\" : \"/\").concat(src);\n            return {\n                src: imgSrc,\n                alt: typeof img === \"object\" && img.alt ? img.alt : data.title || \"Imagen del blog\"\n            };\n        });\n    } else if (data.image) {\n        if (typeof data.image === \"string\") {\n            const imageSrc = data.image.startsWith(\"http\") ? data.image : \"\".concat(API_URL).concat(data.image.startsWith(\"/\") ? \"\" : \"/\").concat(data.image);\n            blogImages = [\n                {\n                    src: imageSrc,\n                    alt: data.title || \"Imagen del blog\"\n                }\n            ];\n        } else {\n            const src = data.image.src || data.image.url || \"\";\n            blogImages = [\n                {\n                    ...data.image,\n                    src: src.startsWith(\"http\") ? src : \"\".concat(API_URL).concat(src.startsWith(\"/\") ? \"\" : \"/\").concat(src)\n                }\n            ];\n        }\n    }\n    if (blogImages.length === 0) {\n        blogImages = [\n            {\n                src: \"/img/default-blog-image.jpg\",\n                alt: data.title || \"Imagen del blog\"\n            }\n        ];\n    }\n    return {\n        ...data,\n        _id: data._id,\n        title: data.title || \"Sin t\\xedtulo\",\n        content: data.content || data.description || \"\",\n        description: data.description || data.excerpt || \"\",\n        date: data.createdAt || data.date || new Date().toISOString(),\n        dateFormatted: data.dateFormatted || (data.createdAt ? new Date(data.createdAt).toLocaleDateString(\"es-ES\") : new Date().toLocaleDateString(\"es-ES\")),\n        images: blogImages,\n        image: blogImages[0],\n        imageUrl: ((_blogImages_ = blogImages[0]) === null || _blogImages_ === void 0 ? void 0 : _blogImages_.src) || \"/img/default-blog-image.jpg\",\n        source: \"mongodb\"\n    };\n}\n// Función auxiliar para procesar blogs de WordPress\nfunction procesarBlogWordPress(data) {\n    var _data_title, _data_content, _data_excerpt, _data_title1, _data_title2;\n    let featuredImage = null;\n    if (data._embedded && data._embedded[\"wp:featuredmedia\"] && data._embedded[\"wp:featuredmedia\"][0]) {\n        const media = data._embedded[\"wp:featuredmedia\"][0];\n        if (media.media_details && media.media_details.sizes) {\n            const sizePriority = [\n                \"medium_large\",\n                \"medium\",\n                \"large\",\n                \"full\"\n            ];\n            for (const size of sizePriority){\n                if (media.media_details.sizes[size]) {\n                    featuredImage = media.media_details.sizes[size].source_url;\n                    break;\n                }\n            }\n        }\n        if (!featuredImage && media.source_url) {\n            featuredImage = media.source_url;\n        }\n    }\n    if (!featuredImage && data.uagb_featured_image_src) {\n        var _data_uagb_featured_image_src_medium, _data_uagb_featured_image_src_full;\n        featuredImage = ((_data_uagb_featured_image_src_medium = data.uagb_featured_image_src.medium) === null || _data_uagb_featured_image_src_medium === void 0 ? void 0 : _data_uagb_featured_image_src_medium[0]) || ((_data_uagb_featured_image_src_full = data.uagb_featured_image_src.full) === null || _data_uagb_featured_image_src_full === void 0 ? void 0 : _data_uagb_featured_image_src_full[0]);\n    }\n    if (!featuredImage) {\n        featuredImage = \"/img/default-blog-image.jpg\";\n    }\n    return {\n        ...data,\n        _id: \"wp-\".concat(data.id),\n        id: data.id,\n        title: ((_data_title = data.title) === null || _data_title === void 0 ? void 0 : _data_title.rendered) || data.title || \"\",\n        content: ((_data_content = data.content) === null || _data_content === void 0 ? void 0 : _data_content.rendered) || data.content || \"\",\n        excerpt: ((_data_excerpt = data.excerpt) === null || _data_excerpt === void 0 ? void 0 : _data_excerpt.rendered) || data.excerpt || \"\",\n        date: data.date,\n        dateFormatted: new Date(data.date).toLocaleDateString(\"es-ES\"),\n        images: [\n            {\n                src: featuredImage,\n                alt: ((_data_title1 = data.title) === null || _data_title1 === void 0 ? void 0 : _data_title1.rendered) || data.title || \"Imagen del blog\"\n            }\n        ],\n        image: {\n            src: featuredImage,\n            alt: ((_data_title2 = data.title) === null || _data_title2 === void 0 ? void 0 : _data_title2.rendered) || data.title || \"Imagen del blog\"\n        },\n        imageUrl: featuredImage,\n        slug: data.slug,\n        source: \"wordpress\"\n    };\n}\nasync function getPropertyPosts() {\n    let wpData = [];\n    let mongoData = [];\n    // 1. Intentar obtener propiedades de WooCommerce a través del proxy\n    try {\n        console.log(\"Obteniendo propiedades de WooCommerce...\");\n        // Usar nuestro proxy de Next.js\n        const firstPageResponse = await fetch(\"/api/wordpress-proxy?per_page=100\");\n        console.log(\"Respuesta de WooCommerce:\", {\n            status: firstPageResponse.status,\n            statusText: firstPageResponse.statusText\n        });\n        if (!firstPageResponse.ok) {\n            console.error(\"Error al obtener propiedades de WooCommerce: \".concat(firstPageResponse.status, \" \").concat(firstPageResponse.statusText));\n            throw new Error(\"Error al obtener propiedades: \".concat(firstPageResponse.status));\n        }\n        // Obtener el número total de páginas\n        const totalPages = parseInt(firstPageResponse.headers.get(\"X-WP-TotalPages\") || \"1\");\n        console.log(\"Total de p\\xe1ginas de propiedades: \".concat(totalPages));\n        // Obtener los datos de la primera página\n        const firstPageData = await firstPageResponse.json();\n        // Marcar las propiedades como provenientes de WooCommerce\n        const wpPropertiesWithSource = firstPageData.map((property)=>({\n                ...property,\n                source: \"woocommerce\"\n            }));\n        wpData = [\n            ...wpPropertiesWithSource\n        ];\n        // Si hay más páginas, obtenerlas en paralelo\n        if (totalPages > 1) {\n            const pagePromises = [];\n            for(let page = 2; page <= totalPages; page++){\n                pagePromises.push(fetch(\"/api/wordpress-proxy?page=\".concat(page, \"&per_page=100\")).then((res)=>{\n                    if (!res.ok) throw new Error(\"Error en p\\xe1gina \".concat(page, \": \").concat(res.status));\n                    return res.json();\n                }).then((pageData)=>{\n                    // Marcar las propiedades como provenientes de WooCommerce\n                    return pageData.map((property)=>({\n                            ...property,\n                            source: \"woocommerce\"\n                        }));\n                }));\n            }\n            // Esperar a que todas las promesas adicionales se resuelvan\n            const additionalPagesData = await Promise.all(pagePromises);\n            // Añadir los datos adicionales a wpData\n            additionalPagesData.forEach((pageData)=>{\n                wpData = [\n                    ...wpData,\n                    ...pageData\n                ];\n            });\n        }\n        console.log(\"Total de propiedades de WooCommerce obtenidas: \".concat(wpData.length));\n    } catch (wpError) {\n        console.error(\"Error al obtener propiedades de WooCommerce:\", wpError);\n    }\n    // 2. Intentar obtener propiedades de MongoDB\n    try {\n        console.log(\"Obteniendo propiedades de MongoDB...\");\n        // Usar la ruta correcta con API_URL\n        const mongoResponse = await fetch(\"\".concat(API_URL, \"/property\"));\n        console.log(\"Respuesta de MongoDB:\", {\n            status: mongoResponse.status,\n            statusText: mongoResponse.statusText\n        });\n        if (mongoResponse.ok) {\n            const contentType = mongoResponse.headers.get(\"content-type\");\n            if (contentType && contentType.includes(\"application/json\")) {\n                const properties = await mongoResponse.json();\n                console.log(\"Propiedades de MongoDB obtenidas:\", properties);\n                // Procesar las propiedades para asegurar que tengan el formato correcto\n                mongoData = properties.map((property)=>{\n                    // Procesar las imágenes para asegurar URLs absolutas\n                    let images = [];\n                    if (property.images) {\n                        if (Array.isArray(property.images)) {\n                            images = property.images.map((img)=>{\n                                if (typeof img === \"string\") {\n                                    // Si la imagen es una cadena, verificar si es una URL absoluta\n                                    return img.startsWith(\"http\") ? img : \"\".concat(API_URL).concat(img.startsWith(\"/\") ? \"\" : \"/\").concat(img);\n                                } else if (typeof img === \"object\" && img.url) {\n                                    // Si es un objeto con URL\n                                    return img.url.startsWith(\"http\") ? img.url : \"\".concat(API_URL).concat(img.url.startsWith(\"/\") ? \"\" : \"/\").concat(img.url);\n                                }\n                                return img;\n                            });\n                        } else if (typeof property.images === \"string\") {\n                            // Si images es una cadena\n                            const img = property.images;\n                            images = [\n                                img.startsWith(\"http\") ? img : \"\".concat(API_URL).concat(img.startsWith(\"/\") ? \"\" : \"/\").concat(img)\n                            ];\n                        }\n                    }\n                    // Si no hay imágenes, usar una imagen por defecto\n                    if (images.length === 0) {\n                        images = [\n                            \"/img/default-property-image.jpg\"\n                        ];\n                    }\n                    return {\n                        ...property,\n                        _id: property._id,\n                        title: property.title || property.name || \"Propiedad sin t\\xedtulo\",\n                        description: property.description || \"\",\n                        price: property.price || \"0\",\n                        location: property.location || \"Madrid\",\n                        bedrooms: property.bedrooms || 0,\n                        bathrooms: property.bathrooms || 0,\n                        size: property.m2 || property.area || property.size || 0,\n                        livingArea: property.m2 || property.area || property.size || 0,\n                        images: images,\n                        source: \"mongodb\"\n                    };\n                });\n                console.log(\"Total de propiedades de MongoDB obtenidas: \".concat(mongoData.length));\n            } else {\n                console.error(\"La respuesta no es JSON v\\xe1lido:\", await mongoResponse.text());\n            }\n        } else {\n            try {\n                const errorText = await mongoResponse.text();\n                console.error(\"Error al obtener propiedades de MongoDB: \".concat(mongoResponse.status), errorText);\n            } catch (e) {\n                console.error(\"Error al obtener propiedades de MongoDB: \".concat(mongoResponse.status), mongoResponse.statusText);\n            }\n        }\n    } catch (mongoError) {\n        console.error(\"Error al obtener propiedades de MongoDB:\", mongoError);\n    }\n    // Combinar los resultados de ambas fuentes\n    const combinedData = [\n        ...mongoData,\n        ...wpData\n    ];\n    console.log(\"Total de propiedades combinadas: \".concat(combinedData.length));\n    return combinedData;\n}\nasync function getPropertyById(id) {\n    try {\n        console.log(\"[DEBUG] Iniciando getPropertyById para ID: \".concat(id));\n        // Verificar si estamos en producción\n        const isProduction = \"development\" === \"production\";\n        console.log(\"[DEBUG] \\xbfEstamos en producci\\xf3n? \".concat(isProduction));\n        // Verificar si es un ID de MongoDB\n        const isMongoId = /^[0-9a-fA-F]{24}$/.test(id);\n        console.log(\"[DEBUG] \\xbfEs ID de MongoDB? \".concat(isMongoId));\n        // Configuración de timeout y reintentos para producción\n        const maxRetries = isProduction ? 3 : 1;\n        const timeout = isProduction ? 20000 : 10000;\n        const retryDelay = 1000;\n        let lastError = null;\n        for(let attempt = 1; attempt <= maxRetries; attempt++){\n            try {\n                console.log(\"[DEBUG] Intento \".concat(attempt, \" de \").concat(maxRetries));\n                // Crear un controlador de aborto para el timeout\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>{\n                    console.log(\"[DEBUG] Timeout alcanzado en intento \".concat(attempt));\n                    controller.abort();\n                }, timeout);\n                let response;\n                if (isMongoId) {\n                    // Es un ID de MongoDB\n                    const baseUrl =  false ? 0 : \"\";\n                    const url = \"\".concat(baseUrl, \"/property/\").concat(id);\n                    console.log(\"[DEBUG] Intentando obtener propiedad de MongoDB: \".concat(url));\n                    response = await fetch(url, {\n                        signal: controller.signal,\n                        headers: {\n                            \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n                            \"Pragma\": \"no-cache\",\n                            \"Expires\": \"0\"\n                        }\n                    });\n                } else {\n                    // Es un ID de WooCommerce\n                    const baseUrl =  false ? 0 : \"/api/wordpress-proxy\";\n                    const url = \"\".concat(baseUrl, \"?path=products/\").concat(id);\n                    console.log(\"[DEBUG] Intentando obtener propiedad de WooCommerce: \".concat(url));\n                    response = await fetch(url, {\n                        signal: controller.signal,\n                        headers: {\n                            \"Cache-Control\": \"no-cache, no-store, must-revalidate\",\n                            \"Pragma\": \"no-cache\",\n                            \"Expires\": \"0\"\n                        }\n                    });\n                }\n                clearTimeout(timeoutId);\n                if (!response.ok) {\n                    throw new Error(\"Error HTTP: \".concat(response.status));\n                }\n                const data = await response.json();\n                // Procesar y devolver los datos según el tipo\n                if (isMongoId) {\n                    return procesarDatosMongoDB(data);\n                } else {\n                    return procesarDatosWooCommerce(data);\n                }\n            } catch (error) {\n                console.error(\"[DEBUG] Error en intento \".concat(attempt, \":\"), error);\n                lastError = error;\n                if (attempt < maxRetries) {\n                    console.log(\"[DEBUG] Esperando \".concat(retryDelay, \"ms antes del siguiente intento\"));\n                    await new Promise((resolve)=>setTimeout(resolve, retryDelay));\n                }\n            }\n        }\n        throw lastError || new Error(\"Error al obtener la propiedad despu\\xe9s de varios intentos\");\n    } catch (error) {\n        console.error(\"[DEBUG] Error final en getPropertyById:\", error);\n        throw error;\n    }\n}\n// Función auxiliar para procesar datos de MongoDB\nfunction procesarDatosMongoDB(data) {\n    let images = [];\n    if (data.images) {\n        if (Array.isArray(data.images)) {\n            images = data.images.map((img)=>{\n                if (typeof img === \"string\") {\n                    return img.startsWith(\"http\") ? img : \"\".concat(API_URL).concat(img.startsWith(\"/\") ? \"\" : \"/\").concat(img);\n                } else if (typeof img === \"object\" && img.src) {\n                    const src = img.src.startsWith(\"http\") ? img.src : \"\".concat(API_URL).concat(img.src.startsWith(\"/\") ? \"\" : \"/\").concat(img.src);\n                    return {\n                        ...img,\n                        src\n                    };\n                }\n                return img;\n            }).filter((img)=>img);\n        } else if (typeof data.images === \"string\") {\n            const img = data.images;\n            images = [\n                img.startsWith(\"http\") ? img : \"\".concat(API_URL).concat(img.startsWith(\"/\") ? \"\" : \"/\").concat(img)\n            ];\n        }\n    }\n    if (images.length === 0) {\n        images = [\n            \"/img/default-property-image.jpg\"\n        ];\n    }\n    return {\n        ...data,\n        _id: data._id,\n        title: data.title || data.name || \"Propiedad sin t\\xedtulo\",\n        description: data.description || \"\",\n        price: data.price || \"0\",\n        location: data.location || \"Madrid\",\n        bedrooms: data.bedrooms || data.rooms || 0,\n        bathrooms: data.bathrooms || data.wc || 0,\n        size: data.area || data.m2 || 0,\n        images: images,\n        source: \"mongodb\"\n    };\n}\n// Función auxiliar para procesar datos de WooCommerce\nfunction procesarDatosWooCommerce(data) {\n    var _data_meta_data_find, _data_meta_data, _data_meta_data_find1, _data_meta_data1, _data_meta_data_find2, _data_meta_data2;\n    let images = [];\n    if (data.images && Array.isArray(data.images) && data.images.length > 0) {\n        images = data.images.map((img)=>img.src || img).filter((img)=>img);\n    } else if (data.image && data.image.src) {\n        images = [\n            data.image.src\n        ];\n    }\n    if (images.length === 0) {\n        images = [\n            \"/img/default-property-image.jpg\"\n        ];\n    }\n    return {\n        ...data,\n        id: data.id,\n        title: data.name || \"Propiedad sin t\\xedtulo\",\n        description: data.description || \"\",\n        price: data.price || \"0\",\n        location: data.address || \"Madrid\",\n        bedrooms: ((_data_meta_data = data.meta_data) === null || _data_meta_data === void 0 ? void 0 : (_data_meta_data_find = _data_meta_data.find((m)=>m.key === \"bedrooms\")) === null || _data_meta_data_find === void 0 ? void 0 : _data_meta_data_find.value) || 0,\n        bathrooms: ((_data_meta_data1 = data.meta_data) === null || _data_meta_data1 === void 0 ? void 0 : (_data_meta_data_find1 = _data_meta_data1.find((m)=>m.key === \"bathrooms\")) === null || _data_meta_data_find1 === void 0 ? void 0 : _data_meta_data_find1.value) || 0,\n        size: ((_data_meta_data2 = data.meta_data) === null || _data_meta_data2 === void 0 ? void 0 : (_data_meta_data_find2 = _data_meta_data2.find((m)=>m.key === \"area\")) === null || _data_meta_data_find2 === void 0 ? void 0 : _data_meta_data_find2.value) || 0,\n        images: images,\n        source: \"woocommerce\"\n    };\n}\n// Función para enviar el formulario de contacto\nconst sendEmail = async (data)=>{\n    try {\n        // Reformatear los datos para adaptarse al formato esperado por la API\n        const formattedData = {\n            nombre: data.name,\n            email: data.email,\n            prefix: data.prefix || \"+34\",\n            telefono: data.phone || \"\",\n            asunto: data.message // El mensaje lo enviamos como asunto que es lo que espera el backend\n        };\n        // Validación local actualizada para campos\n        if (!formattedData.nombre || !formattedData.email) {\n            console.error(\"Faltan datos obligatorios:\", formattedData);\n            return {\n                success: false,\n                message: \"Faltan datos requeridos: nombre y email son obligatorios\",\n                error: \"Validaci\\xf3n local\",\n                ok: false\n            };\n        }\n        // Definir el endpoint para el contacto\n        const endpoint = \"\".concat(API_URL, \"/api/contact\");\n        const response = await fetch(endpoint, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(formattedData)\n        });\n        // Capturar la respuesta como texto para debugging\n        const responseText = await response.text();\n        // Intentar parsear la respuesta como JSON\n        let responseData;\n        try {\n            responseData = JSON.parse(responseText);\n        } catch (e) {\n            console.error(\"Respuesta no es JSON v\\xe1lido\");\n            return {\n                success: false,\n                message: \"Formato de respuesta inv\\xe1lido\",\n                error: \"El servidor no respondi\\xf3 con un formato v\\xe1lido\",\n                ok: false\n            };\n        }\n        // Agregar la propiedad ok para compatibilidad con el código existente\n        responseData.ok = response.ok;\n        return responseData;\n    } catch (error) {\n        console.error(\"Error al enviar formulario:\", error);\n        // Devolver un objeto con formato similar al de respuesta exitosa\n        return {\n            success: false,\n            message: \"Error de conexi\\xf3n\",\n            error: error.message,\n            ok: false\n        };\n    }\n};\nconst sendPropertyEmail = async (data)=>{\n    try {\n        const API_URL = \"https://goza-madrid.onrender.com\" || 0;\n        if (data.type === \"offer\") {\n            const endpoint = \"\".concat(API_URL, \"/api/property-offer/create\");\n            // Validar datos requeridos para la oferta\n            if (!data.offerAmount || !data.email || !data.name || !data.phone || !data.propertyId || !data.propertyTitle) {\n                throw new Error(\"Faltan datos de la oferta\");\n            }\n            // Mapear los campos según PropertyOfferSchema\n            const offerData = {\n                property: data.propertyId,\n                propertyAddress: data.propertyTitle,\n                offerPrice: parseFloat(data.offerAmount),\n                offerPercentage: data.offerLabel || \"Personalizada\",\n                email: data.email,\n                name: data.name,\n                phone: data.phone\n            };\n            console.log(\"Enviando datos de oferta:\", offerData);\n            const response = await fetch(endpoint, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(offerData)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.message || \"Error en la respuesta del servidor\");\n            }\n            return await response.json();\n        } else if (data.type === \"visit\") {\n            const endpoint = \"\".concat(API_URL, \"/api/property-visit/create\");\n            // Validar datos requeridos para la visita\n            if (!data.visitDate || !data.visitTime || !data.email || !data.name || !data.phone || !data.propertyId || !data.propertyTitle) {\n                throw new Error(\"Faltan datos de la visita\");\n            }\n            // Mapear los campos según PropertyVisitSchema\n            const visitData = {\n                property: data.propertyId,\n                propertyAddress: data.propertyTitle,\n                date: new Date(data.visitDate),\n                time: new Date(data.visitTime),\n                email: data.email,\n                name: data.name,\n                phone: data.phone,\n                message: data.message || \"\"\n            };\n            console.log(\"Enviando datos de visita:\", visitData);\n            const response = await fetch(endpoint, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(visitData)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.message || \"Error en la respuesta del servidor\");\n            }\n            return await response.json();\n        }\n        throw new Error(\"Tipo de solicitud no v\\xe1lido\");\n    } catch (error) {\n        console.error(\"Error al enviar email:\", error);\n        return {\n            success: false,\n            message: error.message\n        };\n    }\n};\nasync function handler(req, res) {\n    const { url } = req.query;\n    if (!url) {\n        return res.status(400).json({\n            error: \"URL no proporcionada\"\n        });\n    }\n    try {\n        const imageResponse = await fetch(url);\n        const imageBuffer = await imageResponse.arrayBuffer();\n        // Obtener el tipo de contenido\n        const contentType = imageResponse.headers.get(\"content-type\");\n        // Configurar cabeceras de respuesta\n        res.setHeader(\"Content-Type\", contentType);\n        res.setHeader(\"Cache-Control\", \"public, max-age=86400\"); // Cachear por 24 horas\n        // Enviar la imagen\n        res.status(200).send(Buffer.from(imageBuffer));\n    } catch (error) {\n        console.error(\"Error al obtener imagen:\", error);\n        res.status(500).json({\n            error: \"Error al obtener la imagen\"\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQzVCO1FBRUEsTUFBTSxJQUFJckIsTUFBTTtJQUNsQixFQUFFLE9BQU9KLE9BQU87UUFDZEUsUUFBUUYsS0FBSyxDQUFDLDBCQUEwQkE7UUFDeEMsT0FBTztZQUNMc0osU0FBUztZQUNUOUksU0FBU1IsTUFBTVEsT0FBTztRQUN4QjtJQUNGO0FBQ0YsRUFBRTtBQUdhLGVBQWVxSyxRQUFRQyxHQUFHLEVBQUU1RCxHQUFHO0lBQzVDLE1BQU0sRUFBRS9DLEdBQUcsRUFBRSxHQUFHMkcsSUFBSUMsS0FBSztJQUV6QixJQUFJLENBQUM1RyxLQUFLO1FBQ1IsT0FBTytDLElBQUk3RyxNQUFNLENBQUMsS0FBS29CLElBQUksQ0FBQztZQUFFekIsT0FBTztRQUF1QjtJQUM5RDtJQUVBLElBQUk7UUFDRixNQUFNZ0wsZ0JBQWdCLE1BQU1oSyxNQUFNbUQ7UUFDbEMsTUFBTThHLGNBQWMsTUFBTUQsY0FBY0UsV0FBVztRQUVuRCwrQkFBK0I7UUFDL0IsTUFBTTVKLGNBQWMwSixjQUFjOUosT0FBTyxDQUFDSyxHQUFHLENBQUM7UUFFOUMsb0NBQW9DO1FBQ3BDMkYsSUFBSWlFLFNBQVMsQ0FBQyxnQkFBZ0I3SjtRQUM5QjRGLElBQUlpRSxTQUFTLENBQUMsaUJBQWlCLDBCQUEwQix1QkFBdUI7UUFFaEYsbUJBQW1CO1FBQ25CakUsSUFBSTdHLE1BQU0sQ0FBQyxLQUFLK0ssSUFBSSxDQUFDQyxNQUFNQSxDQUFDQyxJQUFJLENBQUNMO0lBQ25DLEVBQUUsT0FBT2pMLE9BQU87UUFDZEUsUUFBUUYsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUNrSCxJQUFJN0csTUFBTSxDQUFDLEtBQUtvQixJQUFJLENBQUM7WUFBRXpCLE9BQU87UUFBNkI7SUFDN0Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvYXBpLmpzP2VhZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRXhwb3J0YXIgc29sbyBsYXMgZnVuY2lvbmVzIGRlIHV0aWxpZGFkIHNpbiBjcmVhciB1bmEgcnV0YSBBUElcbmV4cG9ydCBjb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAwJztcblxuLy8gRGVmaW5pciBsYXMgY2xhdmVzIGRlIEFQSSBkZSBXb29Db21tZXJjZVxuZXhwb3J0IGNvbnN0IFdDX0NPTlNVTUVSX0tFWSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX05FWFRfUFVCTElDX1dPT19DT01NRVJDRV9LRVk7XG5leHBvcnQgY29uc3QgV0NfQ09OU1VNRVJfU0VDUkVUID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfV09PX0NPTU1FUkNFX1NFQ1JFVDtcblxuLy8gRnVuY2nDs24gYXV4aWxpYXIgcGFyYSBtYW5lamFyIGVycm9yZXNcbmV4cG9ydCBjb25zdCBoYW5kbGVBcGlFcnJvciA9IChlcnJvciwgZnVuY3Rpb25OYW1lKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYEVycm9yIGVuICR7ZnVuY3Rpb25OYW1lfTpgLCBlcnJvcik7XG4gIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgIC8vIEVsIHNlcnZpZG9yIHJlc3BvbmRpw7MgY29uIHVuIGPDs2RpZ28gZGUgZXJyb3JcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvci5yZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICB9IGVsc2UgaWYgKGVycm9yLnJlcXVlc3QpIHtcbiAgICAvLyBMYSBwZXRpY2nDs24gZnVlIGhlY2hhIHBlcm8gbm8gc2UgcmVjaWJpw7MgcmVzcHVlc3RhXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBzZSByZWNpYmnDsyByZXNwdWVzdGEgZGVsIHNlcnZpZG9yJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXJyb3IgYWwgY29uZmlndXJhciBsYSBwZXRpY2nDs25cbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgZGVzY29ub2NpZG8nKTtcbiAgfVxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdW50cnlQcmVmaXgoKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coXCJJbnRlbnRhbmRvIG9idGVuZXIgcHJlZmlqb3MgZGUgcGHDrXMgZGVzZGUgbGEgQVBJIGxvY2FsXCIpO1xuICAgIFxuICAgIC8vIFVzYXIgQWJvcnRDb250cm9sbGVyIHBhcmEgZXZpdGFyIGJsb3F1ZW9zXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgNTAwMCk7IC8vIDUgc2VndW5kb3MgdGltZW91dFxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vcHJlZml4YCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSxcbiAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWxcbiAgICB9KTtcbiAgICBcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgIC8vIFNpIGxhIHJlc3B1ZXN0YSBmdWUgZXhpdG9zYSB5IGVzIEpTT04sIGRldm9sdmVyIGxvcyBkYXRvc1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTaSBhbGdvIGZhbGxhLCBkZXZvbHZlciBwcmVmaWpvcyBwb3IgZGVmZWN0b1xuICAgIGNvbnNvbGUubG9nKFwiVXNhbmRvIHByZWZpam9zIGRlIHBhw61zIHBvciBkZWZlY3RvXCIpO1xuICAgIHJldHVybiBnZXREZWZhdWx0Q291bnRyeVByZWZpeGVzKCk7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIG9idGVuZXIgcHJlZmlqb3MgZGUgcGHDrXM6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICAgIC8vIEVuIGNhc28gZGUgZXJyb3IsIGRldm9sdmVyIHByZWZpam9zIHBvciBkZWZlY3RvXG4gICAgcmV0dXJuIGdldERlZmF1bHRDb3VudHJ5UHJlZml4ZXMoKTtcbiAgfVxufVxuXG4vLyBFc3RhIGVzIGxhIGZvcm1hIGNvcnJlY3RhLCB1biBqdW5pb3IgcG9kcsOtYSBoYWNlcmxvIGFzw606XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QmxvZ1Bvc3RzKCkge1xuICAvLyBBcnJheSBkb25kZSBndWFyZGFyZW1vcyB0b2RvcyBsb3MgYmxvZ3NcbiAgbGV0IGFsbEJsb2dzID0gW107XG4gIFxuICAvLyAxLiBJbnRlbnRhciBvYnRlbmVyIGJsb2dzIGRlIFdvcmRQcmVzcyB1c2FuZG8gbnVlc3RybyBwcm94eVxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiT2J0ZW5pZW5kbyBibG9ncyBkZSBXb3JkUHJlc3MuLi5cIik7XG4gICAgXG4gICAgLy8gVXNhciBlbCBwcm94eSBjb24gZWwgcGFyw6FtZXRybyBlbmRwb2ludD13cCBwYXJhIGluZGljYXIgcXVlIHF1ZXJlbW9zIGxhIEFQSSBkZSBXb3JkUHJlc3NcbiAgICBjb25zdCB3cFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBcIi9hcGkvd29yZHByZXNzLXByb3h5P2VuZHBvaW50PXdwJnBhdGg9cG9zdHMmX2VtYmVkPXRydWVcIlxuICAgICk7XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJSZXNwdWVzdGEgZGUgV29yZFByZXNzOlwiLCB7XG4gICAgICBzdGF0dXM6IHdwUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogd3BSZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHdwUmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IHdwQmxvZ3MgPSBhd2FpdCB3cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYE9idGVuaWRvcyAke3dwQmxvZ3MubGVuZ3RofSBibG9ncyBkZSBXb3JkUHJlc3NgKTtcbiAgICAgIFxuICAgICAgLy8gQcOxYWRpciBsb3MgYmxvZ3MgZGUgV29yZFByZXNzIGFsIGFycmF5LCBjb24gbGEgZnVlbnRlIG1hcmNhZGFcbiAgICAgIHdwQmxvZ3MuZm9yRWFjaChibG9nID0+IHtcbiAgICAgICAgLy8gUHJvY2VzYXIgbGEgaW1hZ2VuIGRlc3RhY2FkYVxuICAgICAgICBsZXQgZmVhdHVyZWRJbWFnZSA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICAvLyBJbnRlbnRhciBvYnRlbmVyIGxhIGltYWdlbiBkZXN0YWNhZGEgZGVzZGUgX2VtYmVkZGVkXG4gICAgICAgIGlmIChibG9nLl9lbWJlZGRlZCAmJiBibG9nLl9lbWJlZGRlZFsnd3A6ZmVhdHVyZWRtZWRpYSddICYmIGJsb2cuX2VtYmVkZGVkWyd3cDpmZWF0dXJlZG1lZGlhJ11bMF0pIHtcbiAgICAgICAgICBjb25zdCBtZWRpYSA9IGJsb2cuX2VtYmVkZGVkWyd3cDpmZWF0dXJlZG1lZGlhJ11bMF07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKG1lZGlhLm1lZGlhX2RldGFpbHMgJiYgbWVkaWEubWVkaWFfZGV0YWlscy5zaXplcykge1xuICAgICAgICAgICAgLy8gQnVzY2FyIGxhIG1lam9yIGltYWdlbiBkaXNwb25pYmxlXG4gICAgICAgICAgICBjb25zdCBzaXplUHJpb3JpdHkgPSBbJ21lZGl1bV9sYXJnZScsICdtZWRpdW0nLCAnbGFyZ2UnLCAnZnVsbCddO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpemUgb2Ygc2l6ZVByaW9yaXR5KSB7XG4gICAgICAgICAgICAgIGlmIChtZWRpYS5tZWRpYV9kZXRhaWxzLnNpemVzW3NpemVdKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZWRJbWFnZSA9IG1lZGlhLm1lZGlhX2RldGFpbHMuc2l6ZXNbc2l6ZV0uc291cmNlX3VybDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaSBubyBzZSBlbmNvbnRyw7MgbmluZ3VuYSBpbWFnZW4gZW4gbG9zIHRhbWHDsW9zLCB1c2FyIGxhIFVSTCBkZSBvcmlnZW5cbiAgICAgICAgICBpZiAoIWZlYXR1cmVkSW1hZ2UgJiYgbWVkaWEuc291cmNlX3VybCkge1xuICAgICAgICAgICAgZmVhdHVyZWRJbWFnZSA9IG1lZGlhLnNvdXJjZV91cmw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTaSBubyBoYXkgaW1hZ2VuIGRlc3RhY2FkYSwgaW50ZW50YXIgb2J0ZW5lcmxhIGRlIHVhZ2JfZmVhdHVyZWRfaW1hZ2Vfc3JjXG4gICAgICAgIGlmICghZmVhdHVyZWRJbWFnZSAmJiBibG9nLnVhZ2JfZmVhdHVyZWRfaW1hZ2Vfc3JjKSB7XG4gICAgICAgICAgZmVhdHVyZWRJbWFnZSA9IGJsb2cudWFnYl9mZWF0dXJlZF9pbWFnZV9zcmMubWVkaXVtPy5bMF0gfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2cudWFnYl9mZWF0dXJlZF9pbWFnZV9zcmMuZnVsbD8uWzBdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTaSBhw7puIG5vIGhheSBpbWFnZW4sIHVzYXIgdW5hIGltYWdlbiBwb3IgZGVmZWN0b1xuICAgICAgICBpZiAoIWZlYXR1cmVkSW1hZ2UpIHtcbiAgICAgICAgICBmZWF0dXJlZEltYWdlID0gJy9pbWcvZGVmYXVsdC1ibG9nLWltYWdlLmpwZyc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWFyIGVsIG9iamV0byBkZSBibG9nIGNvbiBsYSBpbWFnZW4gcHJvY2VzYWRhXG4gICAgICAgIGFsbEJsb2dzLnB1c2goe1xuICAgICAgICAgIC4uLmJsb2csXG4gICAgICAgICAgaW1hZ2U6IHtcbiAgICAgICAgICAgIHNyYzogZmVhdHVyZWRJbWFnZSxcbiAgICAgICAgICAgIGFsdDogYmxvZy50aXRsZT8ucmVuZGVyZWQgfHwgYmxvZy50aXRsZSB8fCAnSW1hZ2VuIGRlbCBibG9nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IGJsb2cudGl0bGU/LnJlbmRlcmVkIHx8IGJsb2cudGl0bGUgfHwgJycsXG4gICAgICAgICAgY29udGVudDogYmxvZy5jb250ZW50Py5yZW5kZXJlZCB8fCBibG9nLmNvbnRlbnQgfHwgJycsXG4gICAgICAgICAgZXhjZXJwdDogYmxvZy5leGNlcnB0Py5yZW5kZXJlZCB8fCBibG9nLmV4Y2VycHQgfHwgJycsXG4gICAgICAgICAgc291cmNlOiAnd29yZHByZXNzJ1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCB3cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFsIG9idGVuZXIgYmxvZ3MgZGUgV29yZFByZXNzOiAke3dwUmVzcG9uc2Uuc3RhdHVzfWAsIGVycm9yRGF0YSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb24gV29yZFByZXNzOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgfVxuICBcbiAgLy8gMi4gSW50ZW50YXIgb2J0ZW5lciBibG9ncyBkZSBNb25nb0RCIHVzYW5kbyBsYSBBUEkgZGlyZWN0YVxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiT2J0ZW5pZW5kbyBibG9ncyBkZSBNb25nb0RCLi4uXCIpO1xuICAgIFxuICAgIC8vIFVzYXIgbGEgcnV0YSBjb3JyZWN0YSBjb24gQVBJX1VSTFxuICAgIGNvbnN0IG1vbmdvUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9ibG9nYCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiUmVzcHVlc3RhIGRlIE1vbmdvREI6XCIsIHtcbiAgICAgIHN0YXR1czogbW9uZ29SZXNwb25zZS5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBtb25nb1Jlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB9KTtcbiAgICBcbiAgICBpZiAobW9uZ29SZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBtb25nb1Jlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgIGNvbnN0IG1vbmdvQmxvZ3MgPSBhd2FpdCBtb25nb1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBPYnRlbmlkb3MgJHttb25nb0Jsb2dzLmxlbmd0aH0gYmxvZ3MgZGUgTW9uZ29EQmApO1xuICAgICAgICBcbiAgICAgICAgLy8gQcOxYWRpciBsb3MgYmxvZ3MgZGUgTW9uZ29EQiBhbCBhcnJheSwgY29uIGxhIGZ1ZW50ZSBtYXJjYWRhXG4gICAgICAgIG1vbmdvQmxvZ3MuZm9yRWFjaChibG9nID0+IHtcbiAgICAgICAgICAvLyBQcm9jZXNhciBsYXMgaW3DoWdlbmVzIHNlZ8O6biBlbCBlc3F1ZW1hXG4gICAgICAgICAgbGV0IGJsb2dJbWFnZXMgPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZmljYXIgc2kgZWwgYmxvZyB0aWVuZSBpbcOhZ2VuZXNcbiAgICAgICAgICBpZiAoYmxvZy5pbWFnZXMgJiYgQXJyYXkuaXNBcnJheShibG9nLmltYWdlcykgJiYgYmxvZy5pbWFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gVXNhciBsYXMgaW3DoWdlbmVzIGRlbCBlc3F1ZW1hXG4gICAgICAgICAgICBibG9nSW1hZ2VzID0gYmxvZy5pbWFnZXMubWFwKGltZyA9PiB7XG4gICAgICAgICAgICAgIC8vIEFzZWd1cmFyc2UgZGUgcXVlIGxhIFVSTCBzZWEgYWJzb2x1dGFcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gdHlwZW9mIGltZyA9PT0gJ3N0cmluZycgXG4gICAgICAgICAgICAgICAgPyBpbWcgXG4gICAgICAgICAgICAgICAgOiAoaW1nLnNyYyB8fCAnJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSBzcmMuc3RhcnRzV2l0aCgnaHR0cCcpIFxuICAgICAgICAgICAgICAgID8gc3JjIFxuICAgICAgICAgICAgICAgIDogYCR7QVBJX1VSTH0ke3NyYy5zdGFydHNXaXRoKCcvJykgPyAnJyA6ICcvJ30ke3NyY31gO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcmM6IGltZ1NyYyxcbiAgICAgICAgICAgICAgICBhbHQ6ICh0eXBlb2YgaW1nID09PSAnb2JqZWN0JyAmJiBpbWcuYWx0KSA/IGltZy5hbHQgOiAoYmxvZy50aXRsZSB8fCAnSW1hZ2VuIGRlbCBibG9nJylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmxvZy5pbWFnZSkge1xuICAgICAgICAgICAgLy8gQ29tcGF0aWJpbGlkYWQgY29uIGVsIGZvcm1hdG8gYW50ZXJpb3JcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYmxvZy5pbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gU2kgbGEgaW1hZ2VuIGVzIHVuYSBjYWRlbmEsIGNyZWFyIHVuIG9iamV0byBkZSBpbWFnZW5cbiAgICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IEFQSV9VUkw7XG4gICAgICAgICAgICAgIGNvbnN0IGltYWdlU3JjID0gYmxvZy5pbWFnZS5zdGFydHNXaXRoKCdodHRwJykgXG4gICAgICAgICAgICAgICAgPyBibG9nLmltYWdlIFxuICAgICAgICAgICAgICAgIDogYCR7YmFzZVVybH0ke2Jsb2cuaW1hZ2Uuc3RhcnRzV2l0aCgnLycpID8gJycgOiAnLyd9JHtibG9nLmltYWdlfWA7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBibG9nSW1hZ2VzID0gW3sgXG4gICAgICAgICAgICAgICAgc3JjOiBpbWFnZVNyYywgXG4gICAgICAgICAgICAgICAgYWx0OiBibG9nLnRpdGxlIHx8ICdJbWFnZW4gZGVsIGJsb2cnIFxuICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFNpIHlhIGVzIHVuIG9iamV0bywgYXNlZ3VyYXJzZSBkZSBxdWUgbGEgVVJMIHNlYSBhYnNvbHV0YVxuICAgICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gQVBJX1VSTDtcbiAgICAgICAgICAgICAgY29uc3Qgc3JjID0gYmxvZy5pbWFnZS5zcmMgfHwgYmxvZy5pbWFnZS51cmwgfHwgJyc7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBibG9nSW1hZ2VzID0gW3tcbiAgICAgICAgICAgICAgICAuLi5ibG9nLmltYWdlLFxuICAgICAgICAgICAgICAgIHNyYzogc3JjLnN0YXJ0c1dpdGgoJ2h0dHAnKSBcbiAgICAgICAgICAgICAgICAgID8gc3JjIFxuICAgICAgICAgICAgICAgICAgOiBgJHtiYXNlVXJsfSR7c3JjLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7c3JjfWBcbiAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpIG5vIGhheSBpbcOhZ2VuZXMsIHVzYXIgdW5hIHBvciBkZWZlY3RvXG4gICAgICAgICAgICBibG9nSW1hZ2VzID0gW3sgXG4gICAgICAgICAgICAgIHNyYzogJy9pbWcvZGVmYXVsdC1ibG9nLWltYWdlLmpwZycsIFxuICAgICAgICAgICAgICBhbHQ6IGJsb2cudGl0bGUgfHwgJ0ltYWdlbiBkZWwgYmxvZycgXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQXNlZ3VyYXJzZSBkZSBxdWUgZWwgYmxvZyB0ZW5nYSB0b2RvcyBsb3MgY2FtcG9zIG5lY2VzYXJpb3NcbiAgICAgICAgICBhbGxCbG9ncy5wdXNoKHtcbiAgICAgICAgICAgIC4uLmJsb2csXG4gICAgICAgICAgICBfaWQ6IGJsb2cuX2lkIHx8IGBtb25nby0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpfWAsXG4gICAgICAgICAgICB0aXRsZTogYmxvZy50aXRsZSB8fCAnU2luIHTDrXR1bG8nLFxuICAgICAgICAgICAgY29udGVudDogYmxvZy5jb250ZW50IHx8IGJsb2cuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYmxvZy5kZXNjcmlwdGlvbiB8fCBibG9nLmV4Y2VycHQgfHwgJycsXG4gICAgICAgICAgICBkYXRlOiBibG9nLmNyZWF0ZWRBdCB8fCBibG9nLmRhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdHRlZDogYmxvZy5kYXRlRm9ybWF0dGVkIHx8IChibG9nLmNyZWF0ZWRBdCA/IG5ldyBEYXRlKGJsb2cuY3JlYXRlZEF0KS50b0xvY2FsZURhdGVTdHJpbmcoJ2VzLUVTJykgOiBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygnZXMtRVMnKSksXG4gICAgICAgICAgICBpbWFnZXM6IGJsb2dJbWFnZXMsIC8vIEd1YXJkYXIgZWwgYXJyYXkgY29tcGxldG8gZGUgaW3DoWdlbmVzXG4gICAgICAgICAgICBpbWFnZTogYmxvZ0ltYWdlc1swXSB8fCB7IHNyYzogJy9pbWcvZGVmYXVsdC1ibG9nLWltYWdlLmpwZycsIGFsdDogJ0ltYWdlbiBkZWwgYmxvZycgfSwgLy8gQ29tcGF0aWJpbGlkYWQgY29uIGVsIGZvcm1hdG8gYW50ZXJpb3JcbiAgICAgICAgICAgIHNvdXJjZTogJ21vbmdvZGInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkxhIHJlc3B1ZXN0YSBubyBlcyBKU09OIHbDoWxpZG86XCIsIGF3YWl0IG1vbmdvUmVzcG9uc2UudGV4dCgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgbW9uZ29SZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFsIG9idGVuZXIgYmxvZ3MgZGUgTW9uZ29EQjogJHttb25nb1Jlc3BvbnNlLnN0YXR1c31gLCBlcnJvclRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBvYnRlbmVyIGJsb2dzIGRlIE1vbmdvREI6ICR7bW9uZ29SZXNwb25zZS5zdGF0dXN9YCwgbW9uZ29SZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNvbiBNb25nb0RCOlwiLCBlcnJvci5tZXNzYWdlKTtcbiAgfVxuICBcbiAgY29uc29sZS5sb2coYFRvdGFsIGRlIGJsb2dzIG9idGVuaWRvczogJHthbGxCbG9ncy5sZW5ndGh9YCk7XG4gIHJldHVybiBhbGxCbG9ncztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUJsb2dQb3N0KGlkKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0vYmxvZy8ke2lkfWAsIHtcbiAgICBtZXRob2Q6ICdERUxFVEUnLFxuICB9KTtcblxuICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QmxvZ0J5SWQoaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSBJbmljaWFuZG8gZ2V0QmxvZ0J5SWQgcGFyYSBJRDogJHtpZH1gKTtcbiAgICBcbiAgICAvLyBWZXJpZmljYXIgc2kgZXN0YW1vcyBlbiBwcm9kdWNjacOzblxuICAgIGNvbnN0IGlzUHJvZHVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7XG4gICAgY29uc29sZS5sb2coYFtERUJVR10gwr9Fc3RhbW9zIGVuIHByb2R1Y2Npw7NuPyAke2lzUHJvZHVjdGlvbn1gKTtcbiAgICBcbiAgICAvLyBWZXJpZmljYXIgc2kgZXMgdW4gSUQgZGUgTW9uZ29EQlxuICAgIGNvbnN0IGlzTW9uZ29JZCA9IC9eWzAtOWEtZkEtRl17MjR9JC8udGVzdChpZCk7XG4gICAgY29uc29sZS5sb2coYFtERUJVR10gwr9FcyBJRCBkZSBNb25nb0RCPyAke2lzTW9uZ29JZH1gKTtcbiAgICBcbiAgICAvLyBDb25maWd1cmFjacOzbiBkZSB0aW1lb3V0IHkgcmVpbnRlbnRvcyBwYXJhIHByb2R1Y2Npw7NuXG4gICAgY29uc3QgbWF4UmV0cmllcyA9IGlzUHJvZHVjdGlvbiA/IDMgOiAxO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBpc1Byb2R1Y3Rpb24gPyAyMDAwMCA6IDEwMDAwO1xuICAgIGNvbnN0IHJldHJ5RGVsYXkgPSAxMDAwO1xuICAgIFxuICAgIGxldCBsYXN0RXJyb3IgPSBudWxsO1xuICAgIFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heFJldHJpZXM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFtERUJVR10gSW50ZW50byAke2F0dGVtcHR9IGRlICR7bWF4UmV0cmllc31gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWFyIHVuIGNvbnRyb2xhZG9yIGRlIGFib3J0byBwYXJhIGVsIHRpbWVvdXRcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtERUJVR10gVGltZW91dCBhbGNhbnphZG8gZW4gaW50ZW50byAke2F0dGVtcHR9YCk7XG4gICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgXG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc01vbmdvSWQpIHtcbiAgICAgICAgICAvLyBFcyB1biBJRCBkZSBNb25nb0RCXG4gICAgICAgICAgY29uc3QgYmFzZVVybCA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gQVBJX1VSTCA6ICcnO1xuICAgICAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9L2Jsb2cvJHtpZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbREVCVUddIEludGVudGFuZG8gb2J0ZW5lciBibG9nIGRlIE1vbmdvREI6ICR7dXJsfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSwgbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScsXG4gICAgICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAnRXhwaXJlcyc6ICcwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVzIHVuIElEIGRlIFdvcmRQcmVzc1xuICAgICAgICAgIGNvbnN0IHVybCA9IGAvYXBpL3dvcmRwcmVzcy1wcm94eT9lbmRwb2ludD13cCZwYXRoPXBvc3RzLyR7aWR9Jl9lbWJlZD10cnVlYDtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSBJbnRlbnRhbmRvIG9idGVuZXIgYmxvZyBkZSBXb3JkUHJlc3M6ICR7dXJsfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSwgbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScsXG4gICAgICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAnRXhwaXJlcyc6ICcwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIEhUVFA6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzYXIgeSBkZXZvbHZlciBsb3MgZGF0b3Mgc2Vnw7puIGVsIHRpcG9cbiAgICAgICAgaWYgKGlzTW9uZ29JZCkge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNhckJsb2dNb25nb0RCKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNhckJsb2dXb3JkUHJlc3MoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbREVCVUddIEVycm9yIGVuIGludGVudG8gJHthdHRlbXB0fTpgLCBlcnJvcik7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgICBcbiAgICAgICAgaWYgKGF0dGVtcHQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFtERUJVR10gRXNwZXJhbmRvICR7cmV0cnlEZWxheX1tcyBhbnRlcyBkZWwgc2lndWllbnRlIGludGVudG9gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRocm93IGxhc3RFcnJvciB8fCBuZXcgRXJyb3IoJ0Vycm9yIGFsIG9idGVuZXIgZWwgYmxvZyBkZXNwdcOpcyBkZSB2YXJpb3MgaW50ZW50b3MnKTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW0RFQlVHXSBFcnJvciBmaW5hbCBlbiBnZXRCbG9nQnlJZDpcIiwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIEZ1bmNpw7NuIGF1eGlsaWFyIHBhcmEgcHJvY2VzYXIgYmxvZ3MgZGUgTW9uZ29EQlxuZnVuY3Rpb24gcHJvY2VzYXJCbG9nTW9uZ29EQihkYXRhKSB7XG4gIGxldCBibG9nSW1hZ2VzID0gW107XG4gIFxuICBpZiAoZGF0YS5pbWFnZXMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmltYWdlcykgJiYgZGF0YS5pbWFnZXMubGVuZ3RoID4gMCkge1xuICAgIGJsb2dJbWFnZXMgPSBkYXRhLmltYWdlcy5tYXAoaW1nID0+IHtcbiAgICAgIGNvbnN0IHNyYyA9IHR5cGVvZiBpbWcgPT09ICdzdHJpbmcnID8gaW1nIDogKGltZy5zcmMgfHwgJycpO1xuICAgICAgY29uc3QgaW1nU3JjID0gc3JjLnN0YXJ0c1dpdGgoJ2h0dHAnKSA/IHNyYyA6IGAke0FQSV9VUkx9JHtzcmMuc3RhcnRzV2l0aCgnLycpID8gJycgOiAnLyd9JHtzcmN9YDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNyYzogaW1nU3JjLFxuICAgICAgICBhbHQ6ICh0eXBlb2YgaW1nID09PSAnb2JqZWN0JyAmJiBpbWcuYWx0KSA/IGltZy5hbHQgOiAoZGF0YS50aXRsZSB8fCAnSW1hZ2VuIGRlbCBibG9nJylcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZGF0YS5pbWFnZSkge1xuICAgIGlmICh0eXBlb2YgZGF0YS5pbWFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGltYWdlU3JjID0gZGF0YS5pbWFnZS5zdGFydHNXaXRoKCdodHRwJykgPyBkYXRhLmltYWdlIDogYCR7QVBJX1VSTH0ke2RhdGEuaW1hZ2Uuc3RhcnRzV2l0aCgnLycpID8gJycgOiAnLyd9JHtkYXRhLmltYWdlfWA7XG4gICAgICBibG9nSW1hZ2VzID0gW3sgc3JjOiBpbWFnZVNyYywgYWx0OiBkYXRhLnRpdGxlIHx8ICdJbWFnZW4gZGVsIGJsb2cnIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcmMgPSBkYXRhLmltYWdlLnNyYyB8fCBkYXRhLmltYWdlLnVybCB8fCAnJztcbiAgICAgIGJsb2dJbWFnZXMgPSBbe1xuICAgICAgICAuLi5kYXRhLmltYWdlLFxuICAgICAgICBzcmM6IHNyYy5zdGFydHNXaXRoKCdodHRwJykgPyBzcmMgOiBgJHtBUElfVVJMfSR7c3JjLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7c3JjfWBcbiAgICAgIH1dO1xuICAgIH1cbiAgfVxuICBcbiAgaWYgKGJsb2dJbWFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgYmxvZ0ltYWdlcyA9IFt7IHNyYzogJy9pbWcvZGVmYXVsdC1ibG9nLWltYWdlLmpwZycsIGFsdDogZGF0YS50aXRsZSB8fCAnSW1hZ2VuIGRlbCBibG9nJyB9XTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIF9pZDogZGF0YS5faWQsXG4gICAgdGl0bGU6IGRhdGEudGl0bGUgfHwgJ1NpbiB0w610dWxvJyxcbiAgICBjb250ZW50OiBkYXRhLmNvbnRlbnQgfHwgZGF0YS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbiB8fCBkYXRhLmV4Y2VycHQgfHwgJycsXG4gICAgZGF0ZTogZGF0YS5jcmVhdGVkQXQgfHwgZGF0YS5kYXRlIHx8IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkYXRlRm9ybWF0dGVkOiBkYXRhLmRhdGVGb3JtYXR0ZWQgfHwgKGRhdGEuY3JlYXRlZEF0ID8gbmV3IERhdGUoZGF0YS5jcmVhdGVkQXQpLnRvTG9jYWxlRGF0ZVN0cmluZygnZXMtRVMnKSA6IG5ldyBEYXRlKCkudG9Mb2NhbGVEYXRlU3RyaW5nKCdlcy1FUycpKSxcbiAgICBpbWFnZXM6IGJsb2dJbWFnZXMsXG4gICAgaW1hZ2U6IGJsb2dJbWFnZXNbMF0sXG4gICAgaW1hZ2VVcmw6IGJsb2dJbWFnZXNbMF0/LnNyYyB8fCAnL2ltZy9kZWZhdWx0LWJsb2ctaW1hZ2UuanBnJyxcbiAgICBzb3VyY2U6ICdtb25nb2RiJ1xuICB9O1xufVxuXG4vLyBGdW5jacOzbiBhdXhpbGlhciBwYXJhIHByb2Nlc2FyIGJsb2dzIGRlIFdvcmRQcmVzc1xuZnVuY3Rpb24gcHJvY2VzYXJCbG9nV29yZFByZXNzKGRhdGEpIHtcbiAgbGV0IGZlYXR1cmVkSW1hZ2UgPSBudWxsO1xuICBcbiAgaWYgKGRhdGEuX2VtYmVkZGVkICYmIGRhdGEuX2VtYmVkZGVkWyd3cDpmZWF0dXJlZG1lZGlhJ10gJiYgZGF0YS5fZW1iZWRkZWRbJ3dwOmZlYXR1cmVkbWVkaWEnXVswXSkge1xuICAgIGNvbnN0IG1lZGlhID0gZGF0YS5fZW1iZWRkZWRbJ3dwOmZlYXR1cmVkbWVkaWEnXVswXTtcbiAgICBcbiAgICBpZiAobWVkaWEubWVkaWFfZGV0YWlscyAmJiBtZWRpYS5tZWRpYV9kZXRhaWxzLnNpemVzKSB7XG4gICAgICBjb25zdCBzaXplUHJpb3JpdHkgPSBbJ21lZGl1bV9sYXJnZScsICdtZWRpdW0nLCAnbGFyZ2UnLCAnZnVsbCddO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHNpemUgb2Ygc2l6ZVByaW9yaXR5KSB7XG4gICAgICAgIGlmIChtZWRpYS5tZWRpYV9kZXRhaWxzLnNpemVzW3NpemVdKSB7XG4gICAgICAgICAgZmVhdHVyZWRJbWFnZSA9IG1lZGlhLm1lZGlhX2RldGFpbHMuc2l6ZXNbc2l6ZV0uc291cmNlX3VybDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoIWZlYXR1cmVkSW1hZ2UgJiYgbWVkaWEuc291cmNlX3VybCkge1xuICAgICAgZmVhdHVyZWRJbWFnZSA9IG1lZGlhLnNvdXJjZV91cmw7XG4gICAgfVxuICB9XG4gIFxuICBpZiAoIWZlYXR1cmVkSW1hZ2UgJiYgZGF0YS51YWdiX2ZlYXR1cmVkX2ltYWdlX3NyYykge1xuICAgIGZlYXR1cmVkSW1hZ2UgPSBkYXRhLnVhZ2JfZmVhdHVyZWRfaW1hZ2Vfc3JjLm1lZGl1bT8uWzBdIHx8IGRhdGEudWFnYl9mZWF0dXJlZF9pbWFnZV9zcmMuZnVsbD8uWzBdO1xuICB9XG4gIFxuICBpZiAoIWZlYXR1cmVkSW1hZ2UpIHtcbiAgICBmZWF0dXJlZEltYWdlID0gJy9pbWcvZGVmYXVsdC1ibG9nLWltYWdlLmpwZyc7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBfaWQ6IGB3cC0ke2RhdGEuaWR9YCxcbiAgICBpZDogZGF0YS5pZCxcbiAgICB0aXRsZTogZGF0YS50aXRsZT8ucmVuZGVyZWQgfHwgZGF0YS50aXRsZSB8fCAnJyxcbiAgICBjb250ZW50OiBkYXRhLmNvbnRlbnQ/LnJlbmRlcmVkIHx8IGRhdGEuY29udGVudCB8fCAnJyxcbiAgICBleGNlcnB0OiBkYXRhLmV4Y2VycHQ/LnJlbmRlcmVkIHx8IGRhdGEuZXhjZXJwdCB8fCAnJyxcbiAgICBkYXRlOiBkYXRhLmRhdGUsXG4gICAgZGF0ZUZvcm1hdHRlZDogbmV3IERhdGUoZGF0YS5kYXRlKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VzLUVTJyksXG4gICAgaW1hZ2VzOiBbeyBzcmM6IGZlYXR1cmVkSW1hZ2UsIGFsdDogZGF0YS50aXRsZT8ucmVuZGVyZWQgfHwgZGF0YS50aXRsZSB8fCAnSW1hZ2VuIGRlbCBibG9nJyB9XSxcbiAgICBpbWFnZTogeyBzcmM6IGZlYXR1cmVkSW1hZ2UsIGFsdDogZGF0YS50aXRsZT8ucmVuZGVyZWQgfHwgZGF0YS50aXRsZSB8fCAnSW1hZ2VuIGRlbCBibG9nJyB9LFxuICAgIGltYWdlVXJsOiBmZWF0dXJlZEltYWdlLFxuICAgIHNsdWc6IGRhdGEuc2x1ZyxcbiAgICBzb3VyY2U6ICd3b3JkcHJlc3MnXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9wZXJ0eVBvc3RzKCkge1xuICBsZXQgd3BEYXRhID0gW107XG4gIGxldCBtb25nb0RhdGEgPSBbXTtcbiAgXG4gIC8vIDEuIEludGVudGFyIG9idGVuZXIgcHJvcGllZGFkZXMgZGUgV29vQ29tbWVyY2UgYSB0cmF2w6lzIGRlbCBwcm94eVxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiT2J0ZW5pZW5kbyBwcm9waWVkYWRlcyBkZSBXb29Db21tZXJjZS4uLlwiKTtcbiAgICBcbiAgICAvLyBVc2FyIG51ZXN0cm8gcHJveHkgZGUgTmV4dC5qc1xuICAgIGNvbnN0IGZpcnN0UGFnZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvd29yZHByZXNzLXByb3h5P3Blcl9wYWdlPTEwMGApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiUmVzcHVlc3RhIGRlIFdvb0NvbW1lcmNlOlwiLCB7XG4gICAgICBzdGF0dXM6IGZpcnN0UGFnZVJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGZpcnN0UGFnZVJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIWZpcnN0UGFnZVJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhbCBvYnRlbmVyIHByb3BpZWRhZGVzIGRlIFdvb0NvbW1lcmNlOiAke2ZpcnN0UGFnZVJlc3BvbnNlLnN0YXR1c30gJHtmaXJzdFBhZ2VSZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBhbCBvYnRlbmVyIHByb3BpZWRhZGVzOiAke2ZpcnN0UGFnZVJlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gT2J0ZW5lciBlbCBuw7ptZXJvIHRvdGFsIGRlIHDDoWdpbmFzXG4gICAgY29uc3QgdG90YWxQYWdlcyA9IHBhcnNlSW50KGZpcnN0UGFnZVJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdYLVdQLVRvdGFsUGFnZXMnKSB8fCAnMScpO1xuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBkZSBww6FnaW5hcyBkZSBwcm9waWVkYWRlczogJHt0b3RhbFBhZ2VzfWApO1xuICAgIFxuICAgIC8vIE9idGVuZXIgbG9zIGRhdG9zIGRlIGxhIHByaW1lcmEgcMOhZ2luYVxuICAgIGNvbnN0IGZpcnN0UGFnZURhdGEgPSBhd2FpdCBmaXJzdFBhZ2VSZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgLy8gTWFyY2FyIGxhcyBwcm9waWVkYWRlcyBjb21vIHByb3ZlbmllbnRlcyBkZSBXb29Db21tZXJjZVxuICAgIGNvbnN0IHdwUHJvcGVydGllc1dpdGhTb3VyY2UgPSBmaXJzdFBhZ2VEYXRhLm1hcChwcm9wZXJ0eSA9PiAoe1xuICAgICAgLi4ucHJvcGVydHksXG4gICAgICBzb3VyY2U6ICd3b29jb21tZXJjZSdcbiAgICB9KSk7XG4gICAgXG4gICAgd3BEYXRhID0gWy4uLndwUHJvcGVydGllc1dpdGhTb3VyY2VdO1xuICAgIFxuICAgIC8vIFNpIGhheSBtw6FzIHDDoWdpbmFzLCBvYnRlbmVybGFzIGVuIHBhcmFsZWxvXG4gICAgaWYgKHRvdGFsUGFnZXMgPiAxKSB7XG4gICAgICBjb25zdCBwYWdlUHJvbWlzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IHBhZ2UgPSAyOyBwYWdlIDw9IHRvdGFsUGFnZXM7IHBhZ2UrKykge1xuICAgICAgICBwYWdlUHJvbWlzZXMucHVzaChcbiAgICAgICAgICBmZXRjaChgL2FwaS93b3JkcHJlc3MtcHJveHk/cGFnZT0ke3BhZ2V9JnBlcl9wYWdlPTEwMGApXG4gICAgICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBlbiBww6FnaW5hICR7cGFnZX06ICR7cmVzLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocGFnZURhdGEgPT4ge1xuICAgICAgICAgICAgICAvLyBNYXJjYXIgbGFzIHByb3BpZWRhZGVzIGNvbW8gcHJvdmVuaWVudGVzIGRlIFdvb0NvbW1lcmNlXG4gICAgICAgICAgICAgIHJldHVybiBwYWdlRGF0YS5tYXAocHJvcGVydHkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6ICd3b29jb21tZXJjZSdcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXNwZXJhciBhIHF1ZSB0b2RhcyBsYXMgcHJvbWVzYXMgYWRpY2lvbmFsZXMgc2UgcmVzdWVsdmFuXG4gICAgICBjb25zdCBhZGRpdGlvbmFsUGFnZXNEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwocGFnZVByb21pc2VzKTtcbiAgICAgIFxuICAgICAgLy8gQcOxYWRpciBsb3MgZGF0b3MgYWRpY2lvbmFsZXMgYSB3cERhdGFcbiAgICAgIGFkZGl0aW9uYWxQYWdlc0RhdGEuZm9yRWFjaChwYWdlRGF0YSA9PiB7XG4gICAgICAgIHdwRGF0YSA9IFsuLi53cERhdGEsIC4uLnBhZ2VEYXRhXTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgVG90YWwgZGUgcHJvcGllZGFkZXMgZGUgV29vQ29tbWVyY2Ugb2J0ZW5pZGFzOiAke3dwRGF0YS5sZW5ndGh9YCk7XG4gIH0gY2F0Y2ggKHdwRXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWwgb2J0ZW5lciBwcm9waWVkYWRlcyBkZSBXb29Db21tZXJjZTpcIiwgd3BFcnJvcik7XG4gIH1cbiAgXG4gIC8vIDIuIEludGVudGFyIG9idGVuZXIgcHJvcGllZGFkZXMgZGUgTW9uZ29EQlxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiT2J0ZW5pZW5kbyBwcm9waWVkYWRlcyBkZSBNb25nb0RCLi4uXCIpO1xuICAgIFxuICAgIC8vIFVzYXIgbGEgcnV0YSBjb3JyZWN0YSBjb24gQVBJX1VSTFxuICAgIGNvbnN0IG1vbmdvUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfS9wcm9wZXJ0eWApO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiUmVzcHVlc3RhIGRlIE1vbmdvREI6XCIsIHtcbiAgICAgIHN0YXR1czogbW9uZ29SZXNwb25zZS5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiBtb25nb1Jlc3BvbnNlLnN0YXR1c1RleHRcbiAgICB9KTtcbiAgICBcbiAgICBpZiAobW9uZ29SZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBtb25nb1Jlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKTtcbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmNsdWRlcygnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCBtb25nb1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJQcm9waWVkYWRlcyBkZSBNb25nb0RCIG9idGVuaWRhczpcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNhciBsYXMgcHJvcGllZGFkZXMgcGFyYSBhc2VndXJhciBxdWUgdGVuZ2FuIGVsIGZvcm1hdG8gY29ycmVjdG9cbiAgICAgICAgbW9uZ29EYXRhID0gcHJvcGVydGllcy5tYXAocHJvcGVydHkgPT4ge1xuICAgICAgICAgIC8vIFByb2Nlc2FyIGxhcyBpbcOhZ2VuZXMgcGFyYSBhc2VndXJhciBVUkxzIGFic29sdXRhc1xuICAgICAgICAgIGxldCBpbWFnZXMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydHkuaW1hZ2VzKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wZXJ0eS5pbWFnZXMpKSB7XG4gICAgICAgICAgICAgIGltYWdlcyA9IHByb3BlcnR5LmltYWdlcy5tYXAoaW1nID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGltZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNpIGxhIGltYWdlbiBlcyB1bmEgY2FkZW5hLCB2ZXJpZmljYXIgc2kgZXMgdW5hIFVSTCBhYnNvbHV0YVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGltZy5zdGFydHNXaXRoKCdodHRwJykgPyBpbWcgOiBgJHtBUElfVVJMfSR7aW1nLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7aW1nfWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW1nID09PSAnb2JqZWN0JyAmJiBpbWcudXJsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTaSBlcyB1biBvYmpldG8gY29uIFVSTFxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGltZy51cmwuc3RhcnRzV2l0aCgnaHR0cCcpID8gaW1nLnVybCA6IGAke0FQSV9VUkx9JHtpbWcudXJsLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7aW1nLnVybH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW1nO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BlcnR5LmltYWdlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gU2kgaW1hZ2VzIGVzIHVuYSBjYWRlbmFcbiAgICAgICAgICAgICAgY29uc3QgaW1nID0gcHJvcGVydHkuaW1hZ2VzO1xuICAgICAgICAgICAgICBpbWFnZXMgPSBbaW1nLnN0YXJ0c1dpdGgoJ2h0dHAnKSA/IGltZyA6IGAke0FQSV9VUkx9JHtpbWcuc3RhcnRzV2l0aCgnLycpID8gJycgOiAnLyd9JHtpbWd9YF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpIG5vIGhheSBpbcOhZ2VuZXMsIHVzYXIgdW5hIGltYWdlbiBwb3IgZGVmZWN0b1xuICAgICAgICAgIGlmIChpbWFnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpbWFnZXMgPSBbJy9pbWcvZGVmYXVsdC1wcm9wZXJ0eS1pbWFnZS5qcGcnXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnByb3BlcnR5LFxuICAgICAgICAgICAgX2lkOiBwcm9wZXJ0eS5faWQsXG4gICAgICAgICAgICB0aXRsZTogcHJvcGVydHkudGl0bGUgfHwgcHJvcGVydHkubmFtZSB8fCAnUHJvcGllZGFkIHNpbiB0w610dWxvJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBwcm9wZXJ0eS5kZXNjcmlwdGlvbiB8fCAnJyxcbiAgICAgICAgICAgIHByaWNlOiBwcm9wZXJ0eS5wcmljZSB8fCAnMCcsIC8vIE1hbnRlbmVyIGNvbW8gc3RyaW5nXG4gICAgICAgICAgICBsb2NhdGlvbjogcHJvcGVydHkubG9jYXRpb24gfHwgJ01hZHJpZCcsXG4gICAgICAgICAgICBiZWRyb29tczogcHJvcGVydHkuYmVkcm9vbXMgfHwgMCxcbiAgICAgICAgICAgIGJhdGhyb29tczogcHJvcGVydHkuYmF0aHJvb21zIHx8IDAsXG4gICAgICAgICAgICBzaXplOiBwcm9wZXJ0eS5tMiB8fCBwcm9wZXJ0eS5hcmVhIHx8IHByb3BlcnR5LnNpemUgfHwgMCxcbiAgICAgICAgICAgIGxpdmluZ0FyZWE6IHByb3BlcnR5Lm0yIHx8IHByb3BlcnR5LmFyZWEgfHwgcHJvcGVydHkuc2l6ZSB8fCAwLFxuICAgICAgICAgICAgaW1hZ2VzOiBpbWFnZXMsXG4gICAgICAgICAgICBzb3VyY2U6ICdtb25nb2RiJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFRvdGFsIGRlIHByb3BpZWRhZGVzIGRlIE1vbmdvREIgb2J0ZW5pZGFzOiAke21vbmdvRGF0YS5sZW5ndGh9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTGEgcmVzcHVlc3RhIG5vIGVzIEpTT04gdsOhbGlkbzpcIiwgYXdhaXQgbW9uZ29SZXNwb25zZS50ZXh0KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCBtb25nb1Jlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgYWwgb2J0ZW5lciBwcm9waWVkYWRlcyBkZSBNb25nb0RCOiAke21vbmdvUmVzcG9uc2Uuc3RhdHVzfWAsIGVycm9yVGV4dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFsIG9idGVuZXIgcHJvcGllZGFkZXMgZGUgTW9uZ29EQjogJHttb25nb1Jlc3BvbnNlLnN0YXR1c31gLCBtb25nb1Jlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAobW9uZ29FcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhbCBvYnRlbmVyIHByb3BpZWRhZGVzIGRlIE1vbmdvREI6XCIsIG1vbmdvRXJyb3IpO1xuICB9XG4gIFxuICAvLyBDb21iaW5hciBsb3MgcmVzdWx0YWRvcyBkZSBhbWJhcyBmdWVudGVzXG4gIGNvbnN0IGNvbWJpbmVkRGF0YSA9IFsuLi5tb25nb0RhdGEsIC4uLndwRGF0YV07XG4gIFxuICBjb25zb2xlLmxvZyhgVG90YWwgZGUgcHJvcGllZGFkZXMgY29tYmluYWRhczogJHtjb21iaW5lZERhdGEubGVuZ3RofWApO1xuICByZXR1cm4gY29tYmluZWREYXRhO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvcGVydHlCeUlkKGlkKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYFtERUJVR10gSW5pY2lhbmRvIGdldFByb3BlcnR5QnlJZCBwYXJhIElEOiAke2lkfWApO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzaSBlc3RhbW9zIGVuIHByb2R1Y2Npw7NuXG4gICAgY29uc3QgaXNQcm9kdWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcbiAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSDCv0VzdGFtb3MgZW4gcHJvZHVjY2nDs24/ICR7aXNQcm9kdWN0aW9ufWApO1xuICAgIFxuICAgIC8vIFZlcmlmaWNhciBzaSBlcyB1biBJRCBkZSBNb25nb0RCXG4gICAgY29uc3QgaXNNb25nb0lkID0gL15bMC05YS1mQS1GXXsyNH0kLy50ZXN0KGlkKTtcbiAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSDCv0VzIElEIGRlIE1vbmdvREI/ICR7aXNNb25nb0lkfWApO1xuICAgIFxuICAgIC8vIENvbmZpZ3VyYWNpw7NuIGRlIHRpbWVvdXQgeSByZWludGVudG9zIHBhcmEgcHJvZHVjY2nDs25cbiAgICBjb25zdCBtYXhSZXRyaWVzID0gaXNQcm9kdWN0aW9uID8gMyA6IDE7XG4gICAgY29uc3QgdGltZW91dCA9IGlzUHJvZHVjdGlvbiA/IDIwMDAwIDogMTAwMDA7XG4gICAgY29uc3QgcmV0cnlEZWxheSA9IDEwMDA7XG4gICAgXG4gICAgbGV0IGxhc3RFcnJvciA9IG51bGw7XG4gICAgXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSBJbnRlbnRvICR7YXR0ZW1wdH0gZGUgJHttYXhSZXRyaWVzfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXIgdW4gY29udHJvbGFkb3IgZGUgYWJvcnRvIHBhcmEgZWwgdGltZW91dFxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0RFQlVHXSBUaW1lb3V0IGFsY2FuemFkbyBlbiBpbnRlbnRvICR7YXR0ZW1wdH1gKTtcbiAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGlzTW9uZ29JZCkge1xuICAgICAgICAgIC8vIEVzIHVuIElEIGRlIE1vbmdvREJcbiAgICAgICAgICBjb25zdCBiYXNlVXJsID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBBUElfVVJMIDogJyc7XG4gICAgICAgICAgY29uc3QgdXJsID0gYCR7YmFzZVVybH0vcHJvcGVydHkvJHtpZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbREVCVUddIEludGVudGFuZG8gb2J0ZW5lciBwcm9waWVkYWQgZGUgTW9uZ29EQjogJHt1cmx9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby1zdG9yZSwgbXVzdC1yZXZhbGlkYXRlJyxcbiAgICAgICAgICAgICAgJ1ByYWdtYSc6ICduby1jYWNoZScsXG4gICAgICAgICAgICAgICdFeHBpcmVzJzogJzAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRXMgdW4gSUQgZGUgV29vQ29tbWVyY2VcbiAgICAgICAgICBjb25zdCBiYXNlVXJsID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgXG4gICAgICAgICAgICA/IGAke0FQSV9VUkx9L2FwaS93b3JkcHJlc3MtcHJveHlgIFxuICAgICAgICAgICAgOiAnL2FwaS93b3JkcHJlc3MtcHJveHknO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHVybCA9IGAke2Jhc2VVcmx9P3BhdGg9cHJvZHVjdHMvJHtpZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbREVCVUddIEludGVudGFuZG8gb2J0ZW5lciBwcm9waWVkYWQgZGUgV29vQ29tbWVyY2U6ICR7dXJsfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSwgbm8tc3RvcmUsIG11c3QtcmV2YWxpZGF0ZScsXG4gICAgICAgICAgICAgICdQcmFnbWEnOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICAnRXhwaXJlcyc6ICcwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIEhUVFA6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzYXIgeSBkZXZvbHZlciBsb3MgZGF0b3Mgc2Vnw7puIGVsIHRpcG9cbiAgICAgICAgaWYgKGlzTW9uZ29JZCkge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNhckRhdG9zTW9uZ29EQihkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcHJvY2VzYXJEYXRvc1dvb0NvbW1lcmNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW0RFQlVHXSBFcnJvciBlbiBpbnRlbnRvICR7YXR0ZW1wdH06YCwgZXJyb3IpO1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvcjtcbiAgICAgICAgXG4gICAgICAgIGlmIChhdHRlbXB0IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbREVCVUddIEVzcGVyYW5kbyAke3JldHJ5RGVsYXl9bXMgYW50ZXMgZGVsIHNpZ3VpZW50ZSBpbnRlbnRvYCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHJldHJ5RGVsYXkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aHJvdyBsYXN0RXJyb3IgfHwgbmV3IEVycm9yKCdFcnJvciBhbCBvYnRlbmVyIGxhIHByb3BpZWRhZCBkZXNwdcOpcyBkZSB2YXJpb3MgaW50ZW50b3MnKTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW0RFQlVHXSBFcnJvciBmaW5hbCBlbiBnZXRQcm9wZXJ0eUJ5SWQ6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vLyBGdW5jacOzbiBhdXhpbGlhciBwYXJhIHByb2Nlc2FyIGRhdG9zIGRlIE1vbmdvREJcbmZ1bmN0aW9uIHByb2Nlc2FyRGF0b3NNb25nb0RCKGRhdGEpIHtcbiAgbGV0IGltYWdlcyA9IFtdO1xuICBcbiAgaWYgKGRhdGEuaW1hZ2VzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YS5pbWFnZXMpKSB7XG4gICAgICBpbWFnZXMgPSBkYXRhLmltYWdlcy5tYXAoaW1nID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGltZy5zdGFydHNXaXRoKCdodHRwJykgPyBpbWcgOiBgJHtBUElfVVJMfSR7aW1nLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7aW1nfWA7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGltZyA9PT0gJ29iamVjdCcgJiYgaW1nLnNyYykge1xuICAgICAgICAgIGNvbnN0IHNyYyA9IGltZy5zcmMuc3RhcnRzV2l0aCgnaHR0cCcpID8gaW1nLnNyYyA6IGAke0FQSV9VUkx9JHtpbWcuc3JjLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7aW1nLnNyY31gO1xuICAgICAgICAgIHJldHVybiB7IC4uLmltZywgc3JjIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltZztcbiAgICAgIH0pLmZpbHRlcihpbWcgPT4gaW1nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLmltYWdlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGltZyA9IGRhdGEuaW1hZ2VzO1xuICAgICAgaW1hZ2VzID0gW2ltZy5zdGFydHNXaXRoKCdodHRwJykgPyBpbWcgOiBgJHtBUElfVVJMfSR7aW1nLnN0YXJ0c1dpdGgoJy8nKSA/ICcnIDogJy8nfSR7aW1nfWBdO1xuICAgIH1cbiAgfVxuICBcbiAgaWYgKGltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICBpbWFnZXMgPSBbJy9pbWcvZGVmYXVsdC1wcm9wZXJ0eS1pbWFnZS5qcGcnXTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIF9pZDogZGF0YS5faWQsXG4gICAgdGl0bGU6IGRhdGEudGl0bGUgfHwgZGF0YS5uYW1lIHx8ICdQcm9waWVkYWQgc2luIHTDrXR1bG8nLFxuICAgIGRlc2NyaXB0aW9uOiBkYXRhLmRlc2NyaXB0aW9uIHx8ICcnLFxuICAgIHByaWNlOiBkYXRhLnByaWNlIHx8ICcwJyxcbiAgICBsb2NhdGlvbjogZGF0YS5sb2NhdGlvbiB8fCAnTWFkcmlkJyxcbiAgICBiZWRyb29tczogZGF0YS5iZWRyb29tcyB8fCBkYXRhLnJvb21zIHx8IDAsXG4gICAgYmF0aHJvb21zOiBkYXRhLmJhdGhyb29tcyB8fCBkYXRhLndjIHx8IDAsXG4gICAgc2l6ZTogZGF0YS5hcmVhIHx8IGRhdGEubTIgfHwgMCxcbiAgICBpbWFnZXM6IGltYWdlcyxcbiAgICBzb3VyY2U6ICdtb25nb2RiJ1xuICB9O1xufVxuXG4vLyBGdW5jacOzbiBhdXhpbGlhciBwYXJhIHByb2Nlc2FyIGRhdG9zIGRlIFdvb0NvbW1lcmNlXG5mdW5jdGlvbiBwcm9jZXNhckRhdG9zV29vQ29tbWVyY2UoZGF0YSkge1xuICBsZXQgaW1hZ2VzID0gW107XG4gIFxuICBpZiAoZGF0YS5pbWFnZXMgJiYgQXJyYXkuaXNBcnJheShkYXRhLmltYWdlcykgJiYgZGF0YS5pbWFnZXMubGVuZ3RoID4gMCkge1xuICAgIGltYWdlcyA9IGRhdGEuaW1hZ2VzLm1hcChpbWcgPT4gaW1nLnNyYyB8fCBpbWcpLmZpbHRlcihpbWcgPT4gaW1nKTtcbiAgfSBlbHNlIGlmIChkYXRhLmltYWdlICYmIGRhdGEuaW1hZ2Uuc3JjKSB7XG4gICAgaW1hZ2VzID0gW2RhdGEuaW1hZ2Uuc3JjXTtcbiAgfVxuICBcbiAgaWYgKGltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICBpbWFnZXMgPSBbJy9pbWcvZGVmYXVsdC1wcm9wZXJ0eS1pbWFnZS5qcGcnXTtcbiAgfVxuICBcbiAgcmV0dXJuIHtcbiAgICAuLi5kYXRhLFxuICAgIGlkOiBkYXRhLmlkLFxuICAgIHRpdGxlOiBkYXRhLm5hbWUgfHwgJ1Byb3BpZWRhZCBzaW4gdMOtdHVsbycsXG4gICAgZGVzY3JpcHRpb246IGRhdGEuZGVzY3JpcHRpb24gfHwgJycsXG4gICAgcHJpY2U6IGRhdGEucHJpY2UgfHwgJzAnLFxuICAgIGxvY2F0aW9uOiBkYXRhLmFkZHJlc3MgfHwgJ01hZHJpZCcsXG4gICAgYmVkcm9vbXM6IGRhdGEubWV0YV9kYXRhPy5maW5kKG0gPT4gbS5rZXkgPT09ICdiZWRyb29tcycpPy52YWx1ZSB8fCAwLFxuICAgIGJhdGhyb29tczogZGF0YS5tZXRhX2RhdGE/LmZpbmQobSA9PiBtLmtleSA9PT0gJ2JhdGhyb29tcycpPy52YWx1ZSB8fCAwLFxuICAgIHNpemU6IGRhdGEubWV0YV9kYXRhPy5maW5kKG0gPT4gbS5rZXkgPT09ICdhcmVhJyk/LnZhbHVlIHx8IDAsXG4gICAgaW1hZ2VzOiBpbWFnZXMsXG4gICAgc291cmNlOiAnd29vY29tbWVyY2UnXG4gIH07XG59XG5cbi8vIEZ1bmNpw7NuIHBhcmEgZW52aWFyIGVsIGZvcm11bGFyaW8gZGUgY29udGFjdG9cbmV4cG9ydCBjb25zdCBzZW5kRW1haWwgPSBhc3luYyAoZGF0YSkgPT4ge1xuICB0cnkge1xuICAgXG4gICAgXG4gICAgLy8gUmVmb3JtYXRlYXIgbG9zIGRhdG9zIHBhcmEgYWRhcHRhcnNlIGFsIGZvcm1hdG8gZXNwZXJhZG8gcG9yIGxhIEFQSVxuICAgIGNvbnN0IGZvcm1hdHRlZERhdGEgPSB7XG4gICAgICBub21icmU6IGRhdGEubmFtZSxcbiAgICAgIGVtYWlsOiBkYXRhLmVtYWlsLFxuICAgICAgcHJlZml4OiBkYXRhLnByZWZpeCB8fCAnKzM0JyxcbiAgICAgIHRlbGVmb25vOiBkYXRhLnBob25lIHx8ICcnLFxuICAgICAgYXN1bnRvOiBkYXRhLm1lc3NhZ2UgLy8gRWwgbWVuc2FqZSBsbyBlbnZpYW1vcyBjb21vIGFzdW50byBxdWUgZXMgbG8gcXVlIGVzcGVyYSBlbCBiYWNrZW5kXG4gICAgfTtcbiAgICBcbiAgICAvLyBWYWxpZGFjacOzbiBsb2NhbCBhY3R1YWxpemFkYSBwYXJhIGNhbXBvc1xuICAgIGlmICghZm9ybWF0dGVkRGF0YS5ub21icmUgfHwgIWZvcm1hdHRlZERhdGEuZW1haWwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWx0YW4gZGF0b3Mgb2JsaWdhdG9yaW9zOlwiLCBmb3JtYXR0ZWREYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAnRmFsdGFuIGRhdG9zIHJlcXVlcmlkb3M6IG5vbWJyZSB5IGVtYWlsIHNvbiBvYmxpZ2F0b3Jpb3MnLFxuICAgICAgICBlcnJvcjogJ1ZhbGlkYWNpw7NuIGxvY2FsJyxcbiAgICAgICAgb2s6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBEZWZpbmlyIGVsIGVuZHBvaW50IHBhcmEgZWwgY29udGFjdG9cbiAgICBjb25zdCBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2FwaS9jb250YWN0YDtcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmb3JtYXR0ZWREYXRhKSxcbiAgICB9KTtcbiAgICBcbiAgICAvLyBDYXB0dXJhciBsYSByZXNwdWVzdGEgY29tbyB0ZXh0byBwYXJhIGRlYnVnZ2luZ1xuICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBcbiAgICAvLyBJbnRlbnRhciBwYXJzZWFyIGxhIHJlc3B1ZXN0YSBjb21vIEpTT05cbiAgICBsZXQgcmVzcG9uc2VEYXRhO1xuICAgIHRyeSB7XG4gICAgICByZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJlc3B1ZXN0YSBubyBlcyBKU09OIHbDoWxpZG9cIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTogJ0Zvcm1hdG8gZGUgcmVzcHVlc3RhIGludsOhbGlkbycsXG4gICAgICAgIGVycm9yOiAnRWwgc2Vydmlkb3Igbm8gcmVzcG9uZGnDsyBjb24gdW4gZm9ybWF0byB2w6FsaWRvJyxcbiAgICAgICAgb2s6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBBZ3JlZ2FyIGxhIHByb3BpZWRhZCBvayBwYXJhIGNvbXBhdGliaWxpZGFkIGNvbiBlbCBjw7NkaWdvIGV4aXN0ZW50ZVxuICAgIHJlc3BvbnNlRGF0YS5vayA9IHJlc3BvbnNlLm9rO1xuICAgIFxuICAgIHJldHVybiByZXNwb25zZURhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFsIGVudmlhciBmb3JtdWxhcmlvOlwiLCBlcnJvcik7XG4gICAgLy8gRGV2b2x2ZXIgdW4gb2JqZXRvIGNvbiBmb3JtYXRvIHNpbWlsYXIgYWwgZGUgcmVzcHVlc3RhIGV4aXRvc2FcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiAnRXJyb3IgZGUgY29uZXhpw7NuJyxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgb2s6IGZhbHNlXG4gICAgfTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHNlbmRQcm9wZXJ0eUVtYWlsID0gYXN5bmMgKGRhdGEpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cHM6Ly9nb3phLW1hZHJpZC5vbnJlbmRlci5jb20nO1xuICAgIFxuICAgIGlmIChkYXRhLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vYXBpL3Byb3BlcnR5LW9mZmVyL2NyZWF0ZWA7XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXIgZGF0b3MgcmVxdWVyaWRvcyBwYXJhIGxhIG9mZXJ0YVxuICAgICAgaWYgKCFkYXRhLm9mZmVyQW1vdW50IHx8ICFkYXRhLmVtYWlsIHx8ICFkYXRhLm5hbWUgfHwgIWRhdGEucGhvbmUgfHwgIWRhdGEucHJvcGVydHlJZCB8fCAhZGF0YS5wcm9wZXJ0eVRpdGxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFsdGFuIGRhdG9zIGRlIGxhIG9mZXJ0YScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNYXBlYXIgbG9zIGNhbXBvcyBzZWfDum4gUHJvcGVydHlPZmZlclNjaGVtYVxuICAgICAgY29uc3Qgb2ZmZXJEYXRhID0ge1xuICAgICAgICBwcm9wZXJ0eTogZGF0YS5wcm9wZXJ0eUlkLFxuICAgICAgICBwcm9wZXJ0eUFkZHJlc3M6IGRhdGEucHJvcGVydHlUaXRsZSxcbiAgICAgICAgb2ZmZXJQcmljZTogcGFyc2VGbG9hdChkYXRhLm9mZmVyQW1vdW50KSxcbiAgICAgICAgb2ZmZXJQZXJjZW50YWdlOiBkYXRhLm9mZmVyTGFiZWwgfHwgJ1BlcnNvbmFsaXphZGEnLFxuICAgICAgICBlbWFpbDogZGF0YS5lbWFpbCxcbiAgICAgICAgbmFtZTogZGF0YS5uYW1lLFxuICAgICAgICBwaG9uZTogZGF0YS5waG9uZVxuICAgICAgfTtcbiAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdFbnZpYW5kbyBkYXRvcyBkZSBvZmVydGE6Jywgb2ZmZXJEYXRhKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkob2ZmZXJEYXRhKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgJ0Vycm9yIGVuIGxhIHJlc3B1ZXN0YSBkZWwgc2Vydmlkb3InKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAndmlzaXQnKSB7XG4gICAgICBjb25zdCBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2FwaS9wcm9wZXJ0eS12aXNpdC9jcmVhdGVgO1xuICAgICAgXG4gICAgICAvLyBWYWxpZGFyIGRhdG9zIHJlcXVlcmlkb3MgcGFyYSBsYSB2aXNpdGFcbiAgICAgIGlmICghZGF0YS52aXNpdERhdGUgfHwgIWRhdGEudmlzaXRUaW1lIHx8ICFkYXRhLmVtYWlsIHx8ICFkYXRhLm5hbWUgfHwgIWRhdGEucGhvbmUgfHwgIWRhdGEucHJvcGVydHlJZCB8fCAhZGF0YS5wcm9wZXJ0eVRpdGxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFsdGFuIGRhdG9zIGRlIGxhIHZpc2l0YScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNYXBlYXIgbG9zIGNhbXBvcyBzZWfDum4gUHJvcGVydHlWaXNpdFNjaGVtYVxuICAgICAgY29uc3QgdmlzaXREYXRhID0ge1xuICAgICAgICBwcm9wZXJ0eTogZGF0YS5wcm9wZXJ0eUlkLFxuICAgICAgICBwcm9wZXJ0eUFkZHJlc3M6IGRhdGEucHJvcGVydHlUaXRsZSxcbiAgICAgICAgZGF0ZTogbmV3IERhdGUoZGF0YS52aXNpdERhdGUpLFxuICAgICAgICB0aW1lOiBuZXcgRGF0ZShkYXRhLnZpc2l0VGltZSksXG4gICAgICAgIGVtYWlsOiBkYXRhLmVtYWlsLFxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIHBob25lOiBkYXRhLnBob25lLFxuICAgICAgICBtZXNzYWdlOiBkYXRhLm1lc3NhZ2UgfHwgJydcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdFbnZpYW5kbyBkYXRvcyBkZSB2aXNpdGE6JywgdmlzaXREYXRhKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodmlzaXREYXRhKVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UgfHwgJ0Vycm9yIGVuIGxhIHJlc3B1ZXN0YSBkZWwgc2Vydmlkb3InKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaXBvIGRlIHNvbGljaXR1ZCBubyB2w6FsaWRvJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgZW52aWFyIGVtYWlsOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzKSB7XG4gIGNvbnN0IHsgdXJsIH0gPSByZXEucXVlcnk7XG4gIFxuICBpZiAoIXVybCkge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnVVJMIG5vIHByb3BvcmNpb25hZGEnIH0pO1xuICB9XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGltYWdlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGNvbnN0IGltYWdlQnVmZmVyID0gYXdhaXQgaW1hZ2VSZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIFxuICAgIC8vIE9idGVuZXIgZWwgdGlwbyBkZSBjb250ZW5pZG9cbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGltYWdlUmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgIFxuICAgIC8vIENvbmZpZ3VyYXIgY2FiZWNlcmFzIGRlIHJlc3B1ZXN0YVxuICAgIHJlcy5zZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcbiAgICByZXMuc2V0SGVhZGVyKCdDYWNoZS1Db250cm9sJywgJ3B1YmxpYywgbWF4LWFnZT04NjQwMCcpOyAvLyBDYWNoZWFyIHBvciAyNCBob3Jhc1xuICAgIFxuICAgIC8vIEVudmlhciBsYSBpbWFnZW5cbiAgICByZXMuc3RhdHVzKDIwMCkuc2VuZChCdWZmZXIuZnJvbShpbWFnZUJ1ZmZlcikpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIG9idGVuZXIgaW1hZ2VuOicsIGVycm9yKTtcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnRXJyb3IgYWwgb2J0ZW5lciBsYSBpbWFnZW4nIH0pO1xuICB9XG59ICJdLCJuYW1lcyI6WyJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJXQ19DT05TVU1FUl9LRVkiLCJORVhUX1BVQkxJQ19ORVhUX1BVQkxJQ19XT09fQ09NTUVSQ0VfS0VZIiwiV0NfQ09OU1VNRVJfU0VDUkVUIiwiTkVYVF9QVUJMSUNfV09PX0NPTU1FUkNFX1NFQ1JFVCIsImhhbmRsZUFwaUVycm9yIiwiZXJyb3IiLCJmdW5jdGlvbk5hbWUiLCJjb25zb2xlIiwicmVzcG9uc2UiLCJFcnJvciIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJyZXF1ZXN0IiwibWVzc2FnZSIsImdldENvdW50cnlQcmVmaXgiLCJsb2ciLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJjb250ZW50VHlwZSIsImdldCIsImluY2x1ZGVzIiwianNvbiIsImdldERlZmF1bHRDb3VudHJ5UHJlZml4ZXMiLCJnZXRCbG9nUG9zdHMiLCJhbGxCbG9ncyIsIndwUmVzcG9uc2UiLCJ3cEJsb2dzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImJsb2ciLCJmZWF0dXJlZEltYWdlIiwiX2VtYmVkZGVkIiwibWVkaWEiLCJtZWRpYV9kZXRhaWxzIiwic2l6ZXMiLCJzaXplUHJpb3JpdHkiLCJzaXplIiwic291cmNlX3VybCIsInVhZ2JfZmVhdHVyZWRfaW1hZ2Vfc3JjIiwibWVkaXVtIiwiZnVsbCIsInB1c2giLCJpbWFnZSIsInNyYyIsImFsdCIsInRpdGxlIiwicmVuZGVyZWQiLCJjb250ZW50IiwiZXhjZXJwdCIsInNvdXJjZSIsImVycm9yRGF0YSIsIm1vbmdvUmVzcG9uc2UiLCJtb25nb0Jsb2dzIiwiYmxvZ0ltYWdlcyIsImltYWdlcyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImltZyIsImltZ1NyYyIsInN0YXJ0c1dpdGgiLCJiYXNlVXJsIiwiaW1hZ2VTcmMiLCJ1cmwiLCJfaWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZGVzY3JpcHRpb24iLCJkYXRlIiwiY3JlYXRlZEF0IiwidG9JU09TdHJpbmciLCJkYXRlRm9ybWF0dGVkIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwidGV4dCIsImVycm9yVGV4dCIsImUiLCJkZWxldGVCbG9nUG9zdCIsImlkIiwiZ2V0QmxvZ0J5SWQiLCJpc1Byb2R1Y3Rpb24iLCJpc01vbmdvSWQiLCJ0ZXN0IiwibWF4UmV0cmllcyIsInRpbWVvdXQiLCJyZXRyeURlbGF5IiwibGFzdEVycm9yIiwiYXR0ZW1wdCIsImRhdGEiLCJwcm9jZXNhckJsb2dNb25nb0RCIiwicHJvY2VzYXJCbG9nV29yZFByZXNzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbWFnZVVybCIsInNsdWciLCJnZXRQcm9wZXJ0eVBvc3RzIiwid3BEYXRhIiwibW9uZ29EYXRhIiwiZmlyc3RQYWdlUmVzcG9uc2UiLCJ0b3RhbFBhZ2VzIiwicGFyc2VJbnQiLCJmaXJzdFBhZ2VEYXRhIiwid3BQcm9wZXJ0aWVzV2l0aFNvdXJjZSIsInByb3BlcnR5IiwicGFnZVByb21pc2VzIiwicGFnZSIsInRoZW4iLCJyZXMiLCJwYWdlRGF0YSIsImFkZGl0aW9uYWxQYWdlc0RhdGEiLCJhbGwiLCJ3cEVycm9yIiwicHJvcGVydGllcyIsIm5hbWUiLCJwcmljZSIsImxvY2F0aW9uIiwiYmVkcm9vbXMiLCJiYXRocm9vbXMiLCJtMiIsImFyZWEiLCJsaXZpbmdBcmVhIiwibW9uZ29FcnJvciIsImNvbWJpbmVkRGF0YSIsImdldFByb3BlcnR5QnlJZCIsInByb2Nlc2FyRGF0b3NNb25nb0RCIiwicHJvY2VzYXJEYXRvc1dvb0NvbW1lcmNlIiwiZmlsdGVyIiwicm9vbXMiLCJ3YyIsImFkZHJlc3MiLCJtZXRhX2RhdGEiLCJmaW5kIiwibSIsImtleSIsInZhbHVlIiwic2VuZEVtYWlsIiwiZm9ybWF0dGVkRGF0YSIsIm5vbWJyZSIsImVtYWlsIiwicHJlZml4IiwidGVsZWZvbm8iLCJwaG9uZSIsImFzdW50byIsInN1Y2Nlc3MiLCJlbmRwb2ludCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2VEYXRhIiwicGFyc2UiLCJzZW5kUHJvcGVydHlFbWFpbCIsInR5cGUiLCJvZmZlckFtb3VudCIsInByb3BlcnR5SWQiLCJwcm9wZXJ0eVRpdGxlIiwib2ZmZXJEYXRhIiwicHJvcGVydHlBZGRyZXNzIiwib2ZmZXJQcmljZSIsInBhcnNlRmxvYXQiLCJvZmZlclBlcmNlbnRhZ2UiLCJvZmZlckxhYmVsIiwidmlzaXREYXRlIiwidmlzaXRUaW1lIiwidmlzaXREYXRhIiwidGltZSIsImhhbmRsZXIiLCJyZXEiLCJxdWVyeSIsImltYWdlUmVzcG9uc2UiLCJpbWFnZUJ1ZmZlciIsImFycmF5QnVmZmVyIiwic2V0SGVhZGVyIiwic2VuZCIsIkJ1ZmZlciIsImZyb20iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/api.js\n"));

/***/ })

});